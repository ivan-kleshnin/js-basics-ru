# 3.3 Числа

В JS есть только один тип числа (64-bit IEEE 754 double), называемый `number`.
Его достаточно для хранения целых чисел с точностью до 9×10¹⁵.

```js
-1
0
42
99.9
```

Для чисел определены [арифметические операции](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators):

```js
1 + 1  // 2   сложение
1 - 1  // 0   вычитание
10 * 2 // 20  умножение
5 / 2  // 2.5 деление
35 % 5 // 0   деление по модулю
```

Double ведут себя (не)предсказуемо (гугл в помощь):

```js
0.1 + 0.2 // 0.30000000000000004
```

Порядком вычисления можно управлять с помощью скобок:

```js
(1 + 3) * 2 // 8
```

Есть три специальных значения, возникающие в результате арифметич. операций, но не являющиеся настоящими числами:

```js
Infinity  // бесконечность       (1 / 0)
-Infinity // минус бесконечность (-1 / 0)
NaN       // не число            (0 / 0)
```

Для чисел определены [операторы сравнения](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators):

```js
// Проверка на равенство
2 == 1 // false
2 == 2 // true

// Проверка на "больше"
1 > 2 // false
2 > 1 // true

// Проверка на "больше или равно"
1 >= 2 // false
2 >= 1 // true

// Проверка на "меньше"
2 < 1 // false
1 < 2 // true

//  Проверка на "меньше или равно"
2 <= 1 // false
1 <= 2 // true
```

Стоит помнить, что проверка на равенство не рекомендуется для Double в общем случае (неуправляемая точность).

Для чисел определены [битовые операции](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators):

```js
// Битовая инверсия
~0 // -1

// Сдвиги влево и вправо (деление и умножение на 2...)
1 << 2 // 4
2 << 2 // 8
8 >> 1 // 4
8 >> 2 // 2

// Битовый AND
5 & 1 // 1
5 & 3 // 1
5 & 0 // 0

// Битовый OR
5 | 1 // 5
5 | 3 // 7
5 | 0 // 5

// Битовый XOR
7 ^ 7 // 0
0 ^ 7 // 7
```

Битовые операции требуют понимания как числа представляются в двоичной системе (`5 -> ...000101`)
и в классическом веб-программировании используются очень редко.

### Приведение типов

```js
// Из строки
Number("1")  // 1
Number("a1") // NaN
Number("1a") // NaN

// Из строки с парсингом (более устойчивый + можно указать систему счисления)
parseInt("1")  // 1
parseInt("a1") // NaN
parseInt("1a") // 1

// Из массива
// см. reduce

// Из объекта
// см. reduce
```

## NaN и Infinity

NaN – это специальное значение типа `number`. Встроенная функция `isNaN` работает некорректно и не должна использоваться:

```js
isNaN(NaN)       // true
isNaN("foo")     // true
isNaN(undefined) // true
isNaN(null)      // false
isNaN(42)        // false
isNaN([]])       // false
```

Именно эту функцию часто показывают в качестве примера сломанности JS.
Впрочем, ES6 вводит обновлённую версию `Number.isNaN`, которую и следует использовать:

```js
Number.isNaN(NaN)       // true
Number.isNaN("foo")     // false
Number.isNaN(undefined) // false
Number.isNaN(null)      // false
Number.isNaN(42)        // false
Number.isNaN([]])       // false
```

Многих начинающих смущает следующее:

```js
Number.isNaN(0 / 0) // true
typeof (0 / 0)      // "number"
```

Данный пример является образцом практического компромисса, кот. неизбежны при проектировании ЯП.
`Infinity`, -`Infinity` и `NaN` являются специализированными значениями числового типа, хотя в математике
ни бесконечности, ни результат деления нуля на нуль не являются ни значениями ни числами.
Сомневаемся, что вы предпочли бы константы с названиями вида `NotAUsableValueFromANumberClass`.

NaN также является единственным значением в JS, которое не равно самому себе:

```js
NaN == NaN // false
```

Специальные значения для бесконечностей `Infinity` и `-Infinity` нельзя использовать в арифметических операциях:

```js
Infinity + -Infinity // NaN
```

Это корректно, поскольку бесконечности не являются значениями в математическом смысле.
