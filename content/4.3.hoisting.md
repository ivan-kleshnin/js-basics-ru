Рассмотрим следующий пример:

```js
function test() {
  console.log(x)
}

// console.log(x) // ReferenceError (3)

let x = "foo"

console.log(x) // "foo"

test() // > "foo"
```

Всё довольно предсказуемо и не требует объяснений. Так работает большинство языков.
Единственный момент, который может смутить, состоит в том, что функция `test`
объявлена раньше, чем переменная `x`, но её парсинг не вызывает ошибки. Почему?

Всё дело в **хойстинге**. Мы подробно рассмотрим эту концепцию ниже. Пока что, отметим,
что основная польза от хойстинга состоит в возможности объявлять функции в произвольном порядке.
Чтобы понять это, полезно увидеть контр-пример из языка без хойстинга. Например, Clojure:

```clj
(defn test [] ; Объявление функции `test` без аргументов
  (println x) ; Исключение RuntimeException: Unable to resolve symbol: x in this context
)
```

Обратите внимание, что исключение выбрасывается уже на этапе объявления функции!
До вызова функции дело даже не доходит. Проблема исправляется... ручным "хойстингом":

```clj
; Workaround
(declare x) ; !!!

(defn test []
  (println x) ; Исключение не происходит
)

(test) ; null / undefined
```

Нетрудно понять, что для файла экспортирующего множество функций вы будете вынуждены
или объявлять их от низкоуровневых к высокоуровневым (*что не всегда желательно*) или прописывать
`declare` для каждой функции, чтобы не зависеть от порядка. В этом плане, Clojure оказывается
ультра-императивным языком.

К счастью, JS не обладает этой проблемой, поскольку реализует механику хойстинга.

Хойстингом называется "поднятие" переменных (и констант) в начало блока видимости.
Блок видимости зависит от типа декларации: `var`, `let` или `const`. Поднятие же означает, что
декларация переменной внутри блока, независимо от строки, перекрывает видимость переменных из
внешних областей видимости. Рассмотрим пример:

```js
// Пример I =================
let x = "foo"

function test() {
  console.log(x) // undefined
  var x = "bar"
}

test()

// Пример II =================
let x = "foo"

function test() {
  console.log(x) // ReferenceError
  let x = "bar"
}

test()
```

В примере I декларации `var`  внутри функции `test` действует на всё тело функции, перекрывая
внешнюю переменную `x` ДО самой декларации. Использование внутренней переменной `x` до самой инструкция
при этом не запрещается, но не имеет смысла, т.к. переменная остаётся `undefined`.

В примере II декларации `let` внутри функции `test` также действует на всё тело функции, перекрывая
внешнюю переменную `x` ДО самой декларации. Использование внутренней переменной `x` до самой инструкция
при этом запрещается (приводит к райнтайм ошибке).

Декларация `const` ведёт себя аналогично `let`.

Хойстинг часто описывают как "нечто неслыханное", однако:

```py
# Python Language
x = 1

def test():
  print x # UnboundLocalError
  x = 2

test()
```

Базовый слои видимости образуются с помощью функций (модули == функции).

Необъявленная переменная (2) последовательно ищется во внешних слоях видимости:

```js
var x = "global" (1)
function f() {
  console.log(x) // (2) => "global"
}

f()
```

Наличие `var x` декларации (3) устанавливает видимость переменной `x` на уровне функции.
Глобальный `x` (1) при этом перекрывается.

Декларация (3) находится ниже по коду, чем вывод (2) и вложена в условный блок, но это не имеет значения.
К моменту (4) значение переменной уже установлено.

```
var x = "global" (1)
function f() {
  console.log(x) // (2) => undefined
  if (true) {
    var x = "local" // (3)
  }
  console.log(x) // (4) => "local"
}

f()
```

Данное поведение объясняется тем, что на этапе трансляции, все `var` декларации поднимаются (хойстятся!) в начало функции.

let не вылезает за рамки блока

````
var a = 1 // (1)
var b = 2 // (2)

if (a === 1) {
  var a = 11 // переинициализация `a` из (1)
  let b = 22 // перекрытие `b` из (2)

  console.log(a) // 11
  console.log(b) // 22
}

console.log(a) // 11
console.log(b) // 2
```

Это полезно, чтобы счётчики циклов и т.п. не вылезали за рамки блока.

2. Under the hood: variables lifecycle
When the engine works with variables, their lifecycle consists of the following phases:

1. Declaration phase is registering a variable in the scope.
2. Initialization phase is allocating memory and creating a binding for the variable in the scope. At this step the variable is automatically initialized with undefined.
3. Assignment phase is assigning a value to the initialized variable.
A variable has unitialized state when it passed the declaration phase, yet didn't reach the initilization.

https://rainsoft.io/variables-lifecycle-and-why-let-is-not-hoisted/
http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/








There is another great advantage using let as it creates a new lexical environment and also binds fresh value rather than keeping an old reference.

for(var i=0; i<5; i++){
   setTimeout(function(){
      console.log(i);
   },1000)
}

for(let i=0; i<5; i++){
   setTimeout(function(){
      console.log(i);
   },1000)
}







foo(); // works, because `foo` is hoisted

function foo() {}
In contrast, class declarations are not hoisted. Therefore, a class only exists after execution reached its definition and it was evaluated. Accessing it beforehand leads to a ReferenceError:

new Foo(); // ReferenceError

class Foo {}
The reason for this limitation is that classes can have an extends clause whose value is an arbitrary expression. That expression must be evaluated in the proper “location”, its evaluation can’t be hoisted.







functionOne();                  ---------------      var functionOne;
                                | is actually |      functionOne();
var functionOne = function(){   | interpreted |-->
};                              |    like     |      functionOne = function(){
                                ---------------      };


functionTwo();              ---------------      function functionTwo() {
                            | is actually |      };
function functionTwo() {    | interpreted |-->
}                           |    like     |      functionTwo();
                            ---------------

When a function declaration is hoisted, the function body "follows"
so when the function body is evaluated,
the variable will immediately be bound to a function object.
When a variable declaration is hoisted, the initialization does not follow, but is "left behind".
The variable is initialized to undefined at the start of the function body, and will be assigned a
value at its original location in the code. (Actually, it will be assigned a value at every location
where a declaration of a variable with the same name occurs.)

The order of hoisting is also important: function declarations take precedence over variable declarations with the same name, and the last function declaration takes precedence over previous function declarations with the same name.







Another important trait of function declarations is that declaring them conditionally is non-standardized and varies across different environments. You should never rely on functions being declared conditionally and use function expressions instead.

// Never do this!
// Some browsers will declare `foo` as the one returning 'first',
// while others — returning 'second'

if (true) {
  function foo() {
    return 'first';
  }
}
else {
  function foo() {
    return 'second';
  }
}
foo();

// Instead, use function expressions:
var foo;
if (true) {
  foo = function() {
    return 'first';
  };
}
else {
  foo = function() {
    return 'second';
  };
}
foo();




A function declaration is processed when execution enters the context in which it appears, before any step-by-step code is executed. The function it creates is given a proper name (x in the example above), and that name is put in the scope in which the declaration appears.

Because it's processed before any step-by-step code in the same context, you can do things like this:

x(); // Works even though it's above the declaration
function x() {
    console.log('x');
}
Also because it's not part of the step-by-step execution of the code, you can't put it inside a control structure like try, if, switch, while, etc.

if (someCondition) {
    function foo() {    // <===== INVALID AND WILL FAIL ON
    }                   //        MANY ENGINES
}
Some engines will handle the above even though it's invalid, by rewriting it as a function expression on-the-fly. There's talk of adding a function statement to the next spec (ECMAScript6) to codify that. But with current engines, it will not work reliably; don't do it.


