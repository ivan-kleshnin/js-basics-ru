# 4.9 Функции

Перебор или недобор аргументов функции не является синтаксической ошибкой:

```js
function add(x, y) {
  return x + y
}

add()         // синтаксически корректно
add(1)        // +
add(1, 2)     // +
add(1, 2, 3)  // +
```


## Функции

Функции в JS описываются встроенным типом `Function`. Для описания функции существует
несколько синтаксисов:

```js
// 1. Декларация функции (базовый способ)

// 1.1. Может объявлять только именованную функцию

function test() {
  ...
}

// 2. Функциональное выражение

// 2.1 Всегда используется в качестве правой стороны при инициализации переменной или в качестве аргумента
//     Не может существовать само по себе

// 2.2 Может возвращать именованную или анонимную функцию

// Анонимная функция в качестве значения переменной FIXME ES2015 даёт имя test
let test = function () {
  ...
}

// Именованная функция в качестве значения переменной
let test = function test() {
  ...
}

// Анонимная функция в качестве аргумента
map(function (x) {
  ...
}, xs)

// Именованная функция в качестве аргумента
map(function mapper(x) {
  ...
}, xs)

// 3. Функциональное выражение со стрелочной функцией

// Аналогично (2), но использует т.н. стрелочную функцию.
// Стрелочные функции всегда анонимны

// Стрелочная функция в качестве значения переменной
let test = () => {
  ...
}

// Стрелочная функция в качестве аргумента
map(function (x) {
  ...
}, xs)

// 4. Метод класса (всегда именованный)
class Test7 {
  test7() {
    ...
  }
}
```

Разница между анонимной и именованной функцией проявляется при выводе:

```js
console.log(function() {})           // [Function]
console.log(function something() {}) // [Function: something]
```

В т.ч. в стеках ошибок:

```
Error: oh-no
    at /Users/ivankleshnin/.../sample.js:2:9    <-- только имя файла
    at Object.<anonymous> (/.../sample.js:3:3)
    ...
```

```
Error: oh-no
    at something (/.../sample.js:2:9)           <-- имя функции + имя файла
    at Object.<anonymous> (/.../sample.js:3:3)
    ...
```

Кажется хорошей идеей давать имена максимальному числу функций, чтобы дебаггеры и профилировщики
выводили более подробную информацию. Но стоит держать в уме
тот факт, что плохое имя функции может быть хуже, чем отсутствие имени (анти-знание против не-знания).
Оставляем этот выбор на твоё усмотрение, читатель.

Разница между стрелочной и обычной функциями (помимо синтаксиса и вопроса именования),
состоит в различном поведении магического объекта `this`. Это различие будет описано далее.
Некоторые авторы предпочитают использовать стрелочные функции почти везде. Некоторые авторы предпочитают
обычные функции стрелочным за исключением аргументов функций `map`, `filter` и т.п. Этот выбор
также зависит от культуры и бекграунда разработчика.

Стрелочные функции могут иметь однострочное или многострочно тело. Круглые скобки
обязательны, кроме случаев, когда функция ожидает ровно один аргумент. Примеры:

```js
// Аргументы
let foo0  = () => x
let foo1a = x => x
let foo1b = (x) => x
let foo2 = (x, y) => x
let foo3 = (x, y, z) => x

// Многострочное тело
let bar = (x) => {
  ...
}

// Если нужно вернуть запись
let qux = (x) => ({
  name: "John",
  surname: "Galt",
})
```

Функциональное выражение имеет преимущество перед декларацией в том, что его можно каррировать:

```
let map = curry((mapFn, xs) => {
  ...
})

let filter = curry((filterFn, xs) => {

})
```

Каррировать декларацию функции невозможно.

Доступ к магическому объекту `this` возможен не только внутри метода, но и внутри любой функции.
Этот аспект JavaScript настолько уникален, что будет описан в отдельном разделе.

## Магический `this`

В отличие от большинства других языков, значение `this` в JS может определяться в момент вызова, а не
в момент декларации. Механика зависит от типа функции. Стрелочная функция использует т.н. Лексическую
область видимости (`this` зависит от декларации). При этом, совершенно необязательно, чтобы функция
находилась внутри записи или каким-то иным образом "напоминала" метод. Например:

```js
let logThis = () => console.log(this)

logThis() // {global: [Circular], process: .., ...} -- глобальный контекст!
```

В этом случае, декларация стрелочной функции захватывает глобальный `this`, который и выводится
на экран. Что находится в глобальном `this`? Зависит от среды выполнения. В NodeJS – это контекст исполнения, т.е. все глобальные переменные.
В браузере – объект `window`. С обычными функциями всё выглядит ещё более интересно:

```js
let logThis = function () { console.log(this) }

logThis() // {global: [Circular], process: .., ...} -- тоже самое
```

```js
let record = {
  logThis: function () { console.log(this) }
}

record.logThis() // { logThis: [Function: logThis] }
```

Кажется, мы можем сделать зачаточное ООП прямо сейчас:

```js
function makeUser(data) {
  return Object.assign( // мутабельная функция...
    {},                 // не портим data
    data,
    {
      behave: function () {
        console.log(`I'm ${data.name} and I behave!`)
      }
    }
  )
}

let user = makeUser({name: "Jack"})

user.behave() // "I'm Jack and I behave!"
```

Работает. Теперь попробуем кое-что иное:

```js
let record = {
  logThis: function () { console.log(this) }
}

let logThis = record.logThis

logThis() // {global: [Circular], process: .., ...} -- опять глобальный контекст @_@
```

Вот это поворот!


JS всегда имее

class Test {
   foo: bar
}

  Lexical scoping vs dynamic scoping



С другой стороны, в Ruby функции не являются объектами первого порядка, что порождает
целый зоопарк номенклатур: `Blocks`, `Procs`, `Methods` и `Lambdas`...



```js
// Классическое ООП
function Book({title, year}) {
  this.title = title
  this.year = year
}

// Классическое ФП
function Book({title, year}) {
  return {title, year} // поздразумевается добавление сложных значений по умолчанию, иначе – не имеет смысла
}

// Защита от дурака
function Book({title, year}) {
  if (!(this instanceof Book)) { // <-- пропаганда антипаттернов
    return new Book({title, year})
  }

  // ...
}

class Book
}
```






