# 1.4 Синтаксический Блицкриг

## Переменные и присваивания

```js
// Декларации
var x = 1
let y = 2
const z = 3

// Передекларации
var x = 2    // допустимо
let y = 3    // статическая ошибка "SyntaxError: Identifier 'y' has already been declared"
const z = 4  // статическая ошибка "SyntaxError: Identifier 'z' has already been declared"

// Присваивания
x = 3 // допустимо
y = 4 // допустимо
z = 5 // динамическая ошибка "TypeError: Assignment to constant variable"
```

*Разница между статическими и динамическими ошибками приобретёт большее значение
после реализации статических ES модулей.*

В языке также определено несколько составных операторов:

```js
++x
x++
x += 1
// Эквивалентно
x = x + 1
```

Использование последних рекомендуется в ограниченной форме (счётчики в циклах и т.п.).

Разница между различными способами декларации переменных, в основном, касается областей видимости
и возможностей переинициализации переменной. До тех пор, мы будем использовать только декларацию `let`.

## Имена переменных

Могут содержать `$`, `_` и буквенные (Юникод) символы в качестве первого символа. Последующие
символы могут содержать вышеуказанное и числовые символы.

```
let x    // ок
let _x   // ок
let $_x  // ок

let #x   // не ок
let 4x   // не ок
let 4 x  // не ок
```

## Зарезервированные слова

[Полный список](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar)

Зарезервированные слова:

```js
arguments await
break
case catch class const continue
debugger default delete do
else enum export extends
finally for function
implements if import in instanceof
interface
let
new
package private protected public
return
static super switch
this throw try typeof
var void
while with
yield
```

Многие из этих слов до сих пор не нашли никакого применения и остаются
просту "зарезервированными"...

Литералы:

```js
null
false
true
```

Особые значения:

```js
Infinity
NaN
undefined
```

Техническая реализация `null` и `undefined` различается, но это никак не отражается на практике.
`undefined` можно перекрыть в нестрогом режиме. В строгом режиме – просто будет бросаться другое исключение,
чем при попытке перекрыть `null`.

[Strict Mode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode)

Способ внедрения Strict Mode по умолчанию: переход на [ES модули](http://stackoverflow.com/questions/31685262/not-recommended-to-write-out-use-strict-with-es6).

## Значения

В первом приближении, можно считать все значения в JS объектами. Объекты содержат пары ключ-значение
в качестве своего основного или вспомогательного содержания. При обращении к отсутствующему полю,
возвращается специальное значение `undefined`. В некоторых случаях, для доступа к полю требуется
наличие скобок. Часть свойств может соответствовать функциям. Такие свойства называются методами.
Обратите внимание, что никаких классов и/или инстанциирования для вызова
методов или доступа к свойствам, в общем случае, не требуется:

```js
(4.2).length             // undefined
[1, 0, 1].length         // 3
[1, 0, 1].filter(x => x) // [1, 1]
"foobar".length          // 6
"foobar".toUpperCase()   // "FOOBAR"
({foo: "FOO"}).foo       // "FOO"
({bar: "BAR"}).foo       // undefined
```

В отличие от большинства других языков, в JS синтаксис доступа к полям объекта имеет две формы:

```js
let user = {name: "Jack"}
user.name    // "Jack"
user["name"] // "Jack"
```

Квадратные скобочки не обозначают индексирование массива. Это тоже доступ к свойству объекта.
"Точечный" способ короче и чище, однако "скобочный" способам даёт:

1. Возможность доступа по ключу, имя которого не соответствует правилам именования переменных
2. Возможность доступа по ключу, имя которого содержится в переменной

```js
let user = {"-name-": "Jack"}
// user.-name-  // синтаксическая ошибка
user["-name-"]  // "Jack"

let propName = "-name-"
user.propName  // undefined
user[propName] // "Jack"
```

Все ключи преобразуются в строковую форму при чтении или записи. Объектные ключи, в базовом JS, не поддерживаются.

## Основные инструкции

```js
let xs = [1, 1, 1]

// Цикл while
let i = 0
while (i <= xs.length) {
  console.log(xs[i])
  i++
}

// Цикл for
for (let i = 0; i < xs.lenght; i++) {
  console.log(xs[i])
}

// Цикл for-of
for (let x of [1, 1, 1]) {
  // ...
}

// return
function head(xs) {
  return xs[0]
}

// Перехват ошибок
try {                 // Только синхронные ошибки
  throw Error("oops") // Выброс ошибки вручную
} catch (e) {         // Нет возможности перехвата по типу
  console.log(e)
}
                      // Нет поддержки finally / else веток
```

## Функции

Все функции JS являются [вариадическими](https://en.wikipedia.org/wiki/Variadic_function).
Это значит, что вызов функции с меньшим или большим число аргументов не вызывает статическую ошибку.
Аргументы принимаются равными `undefined`. В зависимости от реализации, при этом
может возникать (или не возникать) рантайм ошибка:

```js
head() // TypeError: Cannot read property '0' of undefined -- вызов undefined[0] запрещён

function defaultHead(xs, defaultValue) {
  return xs ? xs[0] : defaultValue
}

defaultHead() // undefined -- вернуло defaultValue
```

Стандарт ES2015 добавляет поддержку аргументов по-умолчанию. В отличие от Python, эти аргументы
вычисляются при каждом вызове функции, т.е. их нельзя испортить мутабельными вызовами:

```js
function badFunction(xs=[]) {
  return xs.push(null)
}

badFunction() // 1 -- push возвращает новую длину массива
badFunction() // 1 -- которая не меняется при последующем вызове
badFunction() // 1 -- что подверждает сохранность оригинального пустого массива
```

Старый паттерн, действовавший до адаптации ES2015, предполагал использование булевского ИЛИ:

```js
function badFunction(xs) {
  xs = xs || []
  return xs.push(null)
}
```

## Коллекции

Базовые коллекции JS описываются массивами (`Array`) и записями (`Object`).
`Array` имеет весьма минималистичный набор методов и свойств:

```js
// Литерал
["foo"]

// Создание массива указанной длины (вариант 1)
Array(2) // [,]

// Создание массива указанной длины (вариант 2)
new Array(2) // [,]

// Создание диапазона (array.keys() возвращает итератор по смещениям)
Array.from(Array(10).keys()) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[...Array(10).keys()]        // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

// Длина
["foo", "bar", "qux"].length // 3

// Чтение по существующему индексу
["foo"][0] // "foo"

// Чтение с перебором индекса
["foo"][1] // undefined

// Чтение с недобором индекса
["foo"][-1] // undefined

// Доступ к отсутсвующему свойству
["foo"].whatever // undefined

// Добавка (мутабельная операция!)
let xs = ["foo"]
xs.push("bar") // 2 -- число элементов в новом массиве @_@
xs // ["foo", "bar"]

// Извлечение (мутабельная операция!)
let xs = ["foo", "bar"]
xs.pop() // "bar"
xs // ["foo"]

// Конкатенация
["foo"].concat(["bar"]) // ["foo", "bar"]

// Срезы
["a", "b", "c"].slice(0, 1) // ["a"]
["a", "b", "c"].slice(1, 3) // ["b", "c"]
["a", "b", "c"].slice(-1)   // ["c"]

// Вставка в массив (мутабельная) (не рекомендуется)
let xs = ["a", "b", "c"]
xs.splice(1, 0, "b1", "b2")
xs // ["a", "b1", "b2", "b", "c"]

// Удаление из массива
TODO

// Трансляция массива
[1, 2, 3].map(x => x * 2) // [2, 4, 6]

// Фильтрация массива
[1, 2, 3].filter(x => x > 2) // [3]

// Свёртка массива
[1, 2, 3].reduce((z, x) => z + x, 0) // 6
```

`Object` ещё более лимитирован (по причинам, которые будут понятны далее). Для работы
с ним используются "статические методы" или сторонние функции. Традиционно, работа с записями,
выходящая за рамки доступа по ключу, сводится к построению массива на базе ключей или значений
и его итерации. Создание новых объектов, на базе старых, обычно осуществляется через `reduce`.

```js
// Литерал
{foo: "FOO"}

// Ключи
Object.keys({foo: "FOO", bar: "BAR"})   // ["foo", "bar"]

// Значения
Object.values({foo: "FOO", bar: "BAR"}) // ["FOO", "BAR"]

// Число полей
Object.keys({foo: "FOO"}).length // 1

// Чтение существующего поля
({foo: "FOO"}).foo // "FOO"

// Чтение отсутствующего поля
({foo: "FOO"}).bar // undefined

// Удаление поля (мутабельная операция!)
let r = {foo: "FOO"}
delete r.foo // true
r            // {}

// Объединение объектов (мутабельная операция!)
Object.assign({a: "A"}, {a: "A"})             // {a: "A"}
Object.assign({}, {a: "A"}, {a: "a"})         // {a: "A"} -- с защитой оригинального объекта от мутации
Object.assign({}, {a: {b: "B"}, {a: {c: "C"}) // {a: {c: "C}} -- объединение работает по shallow принципу

// Трансляция
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return Object.assign(z, {[k]: r[k] * 2})
}, {}) // {foo: 0, bar: 2, qux: 4})

// Фильтрация
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return r[k] ? Object.assign(z, {[k]: r[k]}) : z
}, {}) // {bar: 1, qux: 2}

// Свёртка
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return z + r[k]
}, {}) // 3

({foo: "FOO"}).foo  // "FOO"
({foo: "FOO"}).name // undefined
{foo: "FOO"}).hasOwnProperty("foo"))  // true   -- не приводит к Boolean (поддержка falsy значений)
({foo: "FOO"}).hasOwnProperty("bar")) // false { ... } -- не приводит к Boolean (поддержка falsy значений)
```
