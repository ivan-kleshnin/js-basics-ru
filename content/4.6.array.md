# 3.6 Массивы

Во многих языках в роли базовой коллекции выступают списки (реализуемые как Linked List). В JS это не так.
Базовая коллекция языка называется `Array` и расширяет корневой тип `object`,
добавляя упорядоченность полей и синтаксический сахар при объявлении:

```js
[] instanceof Object // true
[] instanceof Array  // true
```

`["foo", "bar"]` можно рассматривать как `{"0": "foo", "1": "bar"}` с гарантией сохранности порядка полей.
Убедиться в этом несложно:

```
> for (let x in {"0": "bar", "1": "foo"}) { console.log(x) }
0
1

> for (let x in ["foo", "bar"]) { console.log(x) }
0
1
```

Из-за особенностей реализации `Array`, баланс памяти и скорости доступа к элементам коллекций в JS
выглядит иначе, чем во многих других языка.

* Чтение произвольного элемента - O(1)
* Добавление в конец - O(1)
* Добавление в начало - O(n)
* Добавление в произвольное место – O(1) или O(n)
* Удаление произвольного элемента – O(1) или O(n)
* Перестановка элементов - O(1)

Основные операции с массивами:

```js
// Инициализация массива литералом
["foo"]

// Инициализация массива указанной длины (вариант 1)
Array(2) // [,]

// Инициализация массива указанной длины (вариант 2)
new Array(2) // [,]

// Чтение существующего индекса
["foo"][0] // "foo"

// Чтение с перебором индекса
["foo"][1] // undefined

// Чтение с недобором индекса
["foo"][-1] // undefined

// Длина массива
["foo"].length // 1

// Пуш (мутабельный, не рекомендуется)
let xs = ["foo"]
xs.push("bar") // 2
xs // ["foo", "bar"]

// Конкатенация массивов
["foo"].concat(["qux"]) // ["foo", "qux"]

// Срезы массива
["a", "b", "c"].slice(0, 1) // ["a"]
["a", "b", "c"].slice(1, 3) // ["b", "c"]
["a", "b", "c"].slice(-1)   // ["c"]

// Вставка в массив (мутабельная, не рекомендуется)
let xs = ["a", "b", "c"]
xs.splice(1, 0, "b1", "b2")
xs // ["a", "b1", "b2", "b", "c"]

// Трансляция массива
[1, 2, 3].map(x => x * 2) // [2, 4, 6]

// Фильтрация массива
[1, 2, 3].filter(x => x > 2) // [3]

// Свёртка массива
[1, 2, 3].reduce((z, x) => z + x, 0) // 6

// Диапазон (array.keys() возвращает итератор по смещениям)
Array.from(Array(10).keys()) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[...Array(10).keys()]        // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Работа с `Array` через встроенные методы не рекомендуется по причине того, что многие
из них содержат мутабельные операции (`push`, `splice` и т.д.). Некоторые гайды
предлагают способы замены мутабельных операций не иммутабельные эквиваленты (`xs.push(x)` эквивалентно `xs.concat([x])`).

Мы не рекомендуем данных подход по причине его паллиативности, громоздкости и неуниверсальности.
Кроме того, на данный момент, число поддерживаемых методов массива крайне мало.
Наша рекомендация – использовать библиотеки типа [Ramda](http://ramdajs.com), содержащие
полнофункциональный инструментарий для работы с массивами (и не только).

Канонический цикл по массиву (по итератору) выполняется через `for ... of`

```js
for (let x of xs) {
  ...
  if (breakCondition) {
    break
  }
}
```

Поддерживаются также все привычные разновидности циклов:

```js
for (let i = 0; i <= n, i++) { ... }

while (contCondition) { ... }

do { ... } while (contCondition)
```

Обратите внимание на отличия между `for ... in` и `for ... of`.
Первый перебирает поля объекта (включая прототипы), второй – элементы массива.

Всегда отдавайте предпочтение [функциональным техникам](https://github.com/stoeffel/awesome-fp-js) (`map` и ко.) вместо циклов.
Предпочтение последних по причине "быстродействия" свидетельствует о фундаментальном непонимании вопроса быстродействия.
Бенчмарки, гоняющие NOOP циклы могут показывать любые проценты "превосходства". Только вот к реальности
они имеют слабое отношение...

#### Приведение типов

```js
// Из строки
"foo\nbar\nqux".split("\n") // ["foo", "bar", "qux"]

// Из объекта
Object.keys({name: "jack", age: 42})                 // ["name", "age"]
Object.values({name: "jack", age: 42})               // ["jack", 42]
Object.keys({name: "jack", age: 42}).map(key => ...) // [...]
```

Проверка на пустой массив: см. **Булевские значения > приведение типов > из массива**

```

