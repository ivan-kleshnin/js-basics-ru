# Боксирование

Боксированием (от англ. box – коробка) называется процесс замены
примитивного типа соответствующим объектным типом.

Чтобы понять смысл данного процесса, начнём с рассмотрения ключевого
слова `new`, которое мы, до сих пор, оставляли без внимания.

В отличие от большинства языков, в JS есть несколько способов вызвать
функцию. Мы рассмотрим все возможные способы в главе **Функции**, а
на данный момент, ограничимся кратким рассмотрением двух из них.

Любая функция JS, например, `Foo` может быть вызвана как `Foo(x, y, z)`
и как `new Foo(x, y, z)`. Первый способ называется простым вызовом
функции, второй – инстанциированием или созданием экземпляра объекта.

Ещё раз подчеркнём, что вызвать функцию, как конструктор, можно независимо
от того как и где она объявлена. Это радикально отличает JS от, скажем,
Python, где возможность вызова функции `foo()` и инстанциирования
экземпляра класса `Foo()` определяются лексически (в момент объявления).

Результат вызова `Foo(x, y)` и `new Foo(x, y)` в JS, обычно различается,
но может и совпадать! Технические причины и механизмы данного аспекта
будут рассмотрены в разделе **Прототипная модель**.

Структуры данных, не имеющие литерального синтаксиса в JS, чаще всего,
создаются с помощью инстанциирования, т.е. с помощью особого вызова
функции, включающего ключевое слово `new`.

Для трёх примитивных типов в JS определены так называемые, обёрточные О-типы:

* `string` &harr; `String`
* `number` &harr; `Number`
* `boolean` &harr; `Boolean`

Этот случай (наряду с коэрцией), является одним из немногих, где
терминология "примитивный тип" / "объектный тип" представляется обоснованной.

Боксирование состоит в автоматической замене примитива `string` на
объект `String` при невозможности использовать первый (при обращении к полям
примитива).

```js
"some".length // 4
// автоматически заменяется на
new String("some").length // 4
```

Обёрнутое значение автоматически убирается сборщиком мусора после операции.

Использование конструкторов обёрточных типов вручную не рекомендуется, т.к. значения
типов `string` и `String` (`number` и `Number`, `boolean` и `Boolean`) не эквивалентны
и не взаимозаменяемы в общем случае:

```js
typeof "foo"                // "string"
typeof new String("foo")    // "object"
"foo" == new String("foo")  // true
"foo" === new String("foo") // false

typeof false                 // "boolean"
typeof new Boolean(false)    // "object"
false == new Boolean(false)  // true
false === new Boolean(false) // false
```

Поскольку `undefined` и `null` не содержат свойств, типы-обёртки `Null` и `Undefined` в языке не определены.

**Всегда отдавайте предпочтение литералам и не используйте обёрточные типы напрямую**:

```js
[1, 2, 3] /* вместо */ new Array(1, 2, 3)
"foo" /* вместо */ new String("foo")
true /* вместо */ new Boolean(true)
```

Литеральный синтаксис короче и закрыт для потенциальных ошибок:

```js
typeof (new String("foo")) == typeof ("foo") // false -- "object" !== "string"
"foo" === new String("foo")                  // false -- примитив !=== объект
Boolean(new Boolean(false))                  // true  -- приведение типов работает только с примитивами
```

Вызов обёрточных О-типов с объектными аргументами совершенно бесполезен:

```
String({})     // '[object Object]'
new String({}) // [String: '[object Object]'] @_@
```

Новый О-тип `symbol`, добавленный в ES6, бросает исключение при попытке инстанциирования
его функции приведения к типу:

```js
Symbol("unique")     // Symbol(unique)
new Symbol("unique") // TypeError: Symbol is not a constructor
```

Что как бы говорит нам, что возможность вызвать `Boolean`, `Number` и `String`
через `new` является недоработкой языка, которую исправили для нового примитивного типа.

С одной стороны, любую функцию можно вызвать с `new` по дизайну, и обвинять
в заведомо некорректном использовании разработчиков – не обосновано. С другой
стороны, капитализация названия в JS конвенционально указывает на необходимость
вызывать функцию, как конструктор. Что не соответствует практике для трёх
указанных функций.

С точки зрения автора, функции приведения к `boolean`, `number`, `string`
стоило назвать `toBoolean`, `toNumber`, `toString`. Согласовать имена с одноимёнными
хуками-"методами" (сейчас они не находятся в однозначной связи).
Конструкторы примитивных типов, привязанные к одноимённым
капитализированным функциям, – удалить (т.е. не экспозировать).
