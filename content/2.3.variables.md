# Переменные

В JS переменные декларируются перед использованием:

```js
let x
x // undefined
y // ReferenceError
```

Декларация переменной может сопровождаться установкой начального значения:

```js
let x = 1
```

Вы можете декларировать несколько переменных сразу:

```js
let x, y, z = null

// эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать
вас давать переменным короткие имена (плохо именно "подталкивание").
Что ещё более важно, он позволит задать переменным разные начальные
значения, как только это понадобится без реструктурирования кода.

Декларация переменной, технически, разделяется на два этапа:
определение идентификатора и его инициализацию. При этом, данные этапы
далеко не всегда выполняются одновременно (даже если
составляют единую декларацию в коде).

```js
x = 1 // (попытка) присвоения переменной x значения 1
// если x не объявлен – вызывает ReferenceError (в строгом режиме)
// или устанавливает поле глобального объекта (в нестрогом режиме)
```

```js
let x // декларация без инициализации
// эквивалентна
let x = undefined // инициализации значением undefined
```

Программистам Python или Ruby, следует обратить особое внимание
на разницу между декларацией и присваиванием. В указанных языках,
в отличие от JS, они унифицированы в одну операцию.

В JS определены три ключевых слова для декларации переменных:

```js
var x
let y
const z = undefined // для const исходное значение является обязательным
```

Первая разница между ними проявляется при попытках передекларации и переинициализации:

```js
// var разрешает передекларацию
var x
var x // ок

// let не разрешает переинициализацию
let y //
let y // SyntaxError: Identifier 'x' has already been declared

// const не разрешает переинициализацию
const z = undefined
const z // SyntaxError: Identifier 'x' has already been declared
```

```js
// var разрешает переинициализацию
var x
x = 1 // ок

// let разрешает переинициализацию
let y //
y = 1 // ок

// const не разрешает переинициализацию
const z = undefined
z = 1 // TypeError: Assignment to constant variable.
```

Декларация `const` не делает само значение иммутабельным.
В известном смысле, это делает её "лживой", т.к. деформирует само
понятие "константы":

```js
const xs = [] // инициализация мутабельным значением
xs.push(1)    // мутабельная операция
xs            // [1]
```

Разница между тремя декларациями также проявляется в видимости переменных,
поведении при хойстинге и поведении при замыкании внутри цикла. Эти
аспекты будут рассмотрены далее в соотв. главах.

Как и в других высокоуровневых языках, переменные в JS являются ссылками.

Когда переменная ссылается на примитив, она ссылается на фактическое
значение. Операция присваивания копирует значение:

```js
let x = 2 // x ссылается на значение 2
let y = x // y ссылается на значение 2 (копия)
x = 3     // x ссылается на новое значение 3
x         // 3
y         // 2 -- y продолжает ссылаться на 2
```

Когда переменная ссылается на объект, она ссылается на указатель
на объект, образуя два уровня абстракции. Поэтому, в частности, объекты
иногда относят к **референтным** типам:

```js
let xs = [2] // xs ссылается на указатель на значение [2]
let ys = xs  // ys ссылается на указатель на значение [2] (вторая ссылка)
xs = [3]     // xs ссылается на указатель на значение [3]
xs           // [3]
ys           // [2] -- y продолжает ссылаться на [2] (значение не менялось)

// но

xs = [2]   // xs ссылается на указатель на значение [2]
ys = xs    // ys ссылается на указатель на значение [2] (вторая ссылка)
xs.push(3) // мутабельная операция (изменяет значение по указателю)
xs         // [2, 3]
ys         // [2, 3] -- y "увидел" изменения
```

Строго говоря, примитивные значения вполне могут не копироваться, а "перессылаться"
при реализации. Из-за иммутабельности, разница в семантике отсутствует.

Именно так это сделано в Python (образуя, по-сути, рудиментарные Persistent Datastructures).
Однако, в данном гайде мы рассматриваем именно семантику языка, а не его имплементацию,
поэтому не будем углубляться в данный вопрос.

Для простоты, мы часто говорим: "переменная содержит значение X" или
"переменная имеет тип Y". Оба эти высказывания являются искажением
реальности, которое может быть допустимым или нет, в зависимости от
контекста разговора.

Ссылки на значения играют роль в Сборке Мусора. Значение, на которое
не ссылается ни одна переменная, автоматически удаляется.

Мы уже отмечали, что тип в JS присваивается именно значениям.
С точки зрения реализации, переменные в JS имеют один и тот же
ссылочный тип.

Для C-программистов: все переменные в JS передаются по значению.
Однако, как мы помним, значением переменной, может быть указатель.
По этой причине, мы не можем переопределить саму переменную изнутри функции,
однако мы можем изменить (испортить) мутабельный объект:

```js
function cleanerWannabe(xs) {
  xs = [] // локальная переменная ссылается на новое значение
          // желаемый эффект даст xs.clear() или его аналог (если есть)
}

let gs = [1, 2, 3]
clearerWannabe(gs)
gs // [1, 2, 3] -- нет эффекта за пределами функции
```

```js
function cleanerWannabe(xs) {
  xs.push(4) // мутабельная операция, значение по ссылке изменено
}

let gs = [1, 2, 3]
clearerWannabe(gs)
gs // [1, 2, 3, 4] -- эффект за пределами функции
```

Поскольку мутабельность является одной из наиболее частых причин багов,
многие программисты вырабатывают стиль, называемый "защитное копирование":

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs.slice()) // создание "защитной копии"
gs // [1, 2, 3] -- не изменился
```

Этот стиль обладает рядом недостатков. Во-первых, не для всех встроенных
данных определены методы копирования. Для копирования записей, например,
следует писать собственную функцию или использовать библиотеку.
Копирование хост-объектов (TODO описать или дать ссылку) может быть
вообще технически невозможно. Таким образом, "защитное копирование"
является несомненным антипаттерном.

Простейшим решением, полностью снимающим необходимость в последнем,
является отказ от мутабельных операций и переход к созданию новых
объектов  на базе старых, без копирования.

Идея реализуется путём использования функциональных хелперов
типа `map`, `filter` и т.д. JS предоставляет минималистичный набор
подобных хелперов. Для полноценной работы вам, вероятно,
понадобится библиотека вроде [RamdaJS](http://ramdajs.com/).

### Правила именования 

На позиции первого символа, имена переменных в JS могут содержать `$`, `_` и буквенные (Юникод) символы.
На последующих позициях – вышеуказанное плюс числовые символы. Имена переменных не могут быть равны ключевым словам:

```js
let x    // ок
let _x   // ок
let $_x  // ок

let #x   // не ок
let 4x   // не ок
let 4 x  // не ок
let let  // не ок
```

Имена свойств обладают теми же ограничениями, однако могут быть равны ключевым словам:

```js
{
  x: "x",    // ок
  _x: "x",   // ок
  $_x: "x",  // ок
  let: "x"   // ок

  #x: "x"   // не ок
  4x: "x"   // не ок
  4 x: "x"  // не ок
}
```

TODO описать глобальный объект
TODO описать хост объекты
