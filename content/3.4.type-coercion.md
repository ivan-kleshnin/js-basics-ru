# Коэрция типов

Коэрцией в JS называется автоматическое приведение типов. Коэрция
противоположна **боксированию**, рассматриваемому в соотв. главе.

Как мы помним, в JS определены 6 примитивных типов:
`null`, `undefined`, `boolean`, `number`, `string`, `symbol`.

Приведение к типу `undefined` и `null` не имеет смысла:

```js
// Эквивалентно константе
(x) => undefined
(x) => null
```

Тип `symbol` – также является особым случаем.

Поэтому, коэрция в JS выполняется только к трём типам: `string`, `number` и `boolean`.
Коэрция происходит в фиксированном перечне встроенных операций и функций.
Запоминать перечень этих правил, как мы уже обсуждали выше, не имеет смысла.
Гораздо важнее – умение правильно интерпретировать результат.

Правила коэрции из примитива в примитив (П1 -> П2), опять-таки,
зафиксированы в форме таблицы. Поэтому, нас, скорее, интересуют правила
коэрции О -> П.

Для трёх указанных (П) типов в JS имеются встроенные операции `ToString`, `ToNumber`, `ToBoolean`.
Программист не имеет возможности вызвать эти операции напрямую, но может
инициировать их выполнение косвенно.

#### `ToBoolean`

Самый простой вариант. Использует фиксированную таблицу из пяти "falsy" значений:

```js
""
0
NaN
null
undefined
```

Значения из этой таблицы приводятся к `false`. Всё остальное –
считается "truthy" и приводится к `true`.

`ToBoolean` вызывается при ручном приведении к `Boolean`
(см. следующую главу) или при использовании значения в условии:

```js
if (Infinity) {} // эквивалентно if (true)
NaN ? x : y      // эквивалентно y
```

Среди DOM объектов можно найти доп. falsy объекты, но это именно
*исключения* (причём тянущие на *баг*).

#### `ToNumber`

Для примитива, данная конверсия происходит по табличным правилам.
Для объектов, данная конверсия использует результат вызова `this.valueOf()`.
Если данный метод не определён, используется результат вызова `this.toString()`.
Если и данный метод не определён, возникает рантайм исключение.

Значения, полученные из `valueOf` / `toString` должны быть примитивами.
Если они не соотв. типу `number`, происходит очередная коэрция –
на этот раз из примитива в примитив.

`ToNumber` вызывается при ручном приведении к `Number`
(см. следующую главу) или при использовании значения в арифметических
операциях:

```js
> Math.pow(2, {})
NaN
> Math.pow(2, {valueOf: () => 3})
8
> Math.pow(2, {toString: () => "3"})
8
```

#### `ToString`

Для примитива, данная конверсия происходит по табличным правилам.
Для объектов, данная конверсия использует результат вызова `this.toString()`.
Если данный метод не определён, используется результат вызова `this.valueOf()`.
Если и данный метод не определён, возникает рантайм исключение.

Значения, полученные из `toString` / `valueOf` должны быть примитивами.
Если они не соотв. типу `string`, происходит очередная коэрция –
на этот раз из примитива в примитив.

`ToString` вызывается при ручном приведении к `String`
(см. следующую главу) или при использовании значения в строковых
операциях:

```js
> 'f' + {toString: () => 'oo'}
'foo'
> 'f' + {valueOf: () => 12}
f12
```

---

Последние примеры из `ToNumber` и `ToString` как-бы символизирует
бессмысленность и беспощадность автокоэрции.

Технически, `ToNumber` и `ToString` делегируют работу ещё одной
встроенной процедуре `ToPrimitive`, которая вызывает `toString` и/или `valueOf`
в порядке, определяемом хинтом вызова(!). Опустим же завесу жалости над
этой сценой.
