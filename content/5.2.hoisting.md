# Скоупинг и Хойстинг

**Хойстингом** называется "подтягивание" деклараций переменных
в начало блока видимости на этапе компиляции. Сравните следующие два
фрагмента:

```
console.log(x) // ReferenceError
```

```
console.log(x) // undefined
var x
```

Наличие декларации `x` как-будто изменяет поведение программы ДО самой декларации.
На самом деле, изменяется не поведение, а исполняемый код, выстраиваемый
компилятором. Упрощённо говоря, декларация переменной состоит из двух (на самом деле, больше)
этапов. Этап инициализации переменной и этап присваивания (значения)
происходят независимо друг от друга. При этом, инициализация всегда происходит
до выполнения кода, статически. Присвоение значения может происходить
и статически и динамически.

Область видимости переменной в JS зависит от типа её декларации.
Собственно, добавление новых правил видимости переменной и послужило
одной из основных причин добавления новых деклараций (`let` и `const` к
существующему ранее `var`).

---

Стандартизация и адаптация ES модулей ещё не завершена, поэтому
мы пока исключим их из рассмотрения. CommonJS и т.п. эмуляции модулей
базируются на функциях и, соотв. их правила видимости описываются правилами
видимости для функций.

---

## Правила

1\. Область видимости переменной, объявленной с помощью `var`, ограничивается
функциями:

```js
var x = "x" //
console.log(x)  // "basic"
```

```js
function foo() {
  var x = "x" // замкнута в функции
}

console.log(x) // ReferenceError
```

```js
{
  var x = "x" // не замкнута в блоке
}

console.log(x) // "x"
```

2\. Область видимости переменной, объявленной с помощью `let` или `const`,
ограничивается блоками (в т.ч. функциями):

```js
let x = "basic" //
console.log(x)  // "x"
```

```js
function foo() {
  let x = "x" // замкнута в блоке (теле функции)
}

console.log(x) // ReferenceError
```

```js
{
  let x = "x" // замкнута в блоке
}

console.log(x) // ReferenceError
```

С практической точки зрения, хойстинг означает, что
объявление переменной внутри блока видимости блокирует доступ к одноимённой
переменной из внешнего блока видимости независимо от места декларации:

```
let x = "x"
function test() {
  console.log(x)
}
test() // "x"
```

```
let x = "x"
function test() {
  console.log(x) // ReferenceError
  return
  let x
}
test() // "x"
```

Так, в последнем примере, логирование переменной `x` внутри функции `test`
вызывает ошибку несмотря на "доступную" переменную `x` из внешнего скоупа.
Инициализация при этом, с точки зрения исполнения кода, не только ещё
не наступила, но и вообще не достижима, т.к. прерывается строкой `return`.

Однако, как уже было сказано, декларации работают статически и процесс выполнения
кода не играет никакой роли на фазе инициализации.

В языках без хойстинга, в аналогичной ситуации, логирование вывело бы
значение переменной `x` из внешнего скоупа.

Подобное *перекрытие* происходит независимо от типа декларации, но
последний влияет на конкретное поведение при "опережающем" доступе к переменной.

Переменные, объявленные с помощью `var` статически инициализируются значением `undefined`.
Это значение можно читать ДО фактической строки декларации (которая, в рантайме,
выполняет лишь роль присваивания) – см. второй сверху пример кода в данной главе.

Переменные, объявленные с помощью `let` и `const` статически инициализируются
с запретом доступа до строки декларации. Формулировка "не хойстятся", иногда
используемая для описания данного поведения, является неверной.
Их хойстинг легко доказать перекрытием переменных из внешних блоков видимости,
как это было сделано выше. Запрет на чтение – отдельная концепция, формально
называемая Temporal Dead Zone.

Преимущества в поведении `let` и `const` перед `var` достаточно очевидны
и, вероятно, не требуют объяснений. Наличие Temporal Dead Zone позволяет
исключить ошибки программиста.

Мотивации, стоящие за функционалом хойстинга, однако, требуют отдельного пояснения.
Чтобы понять их, полезно увидеть контр-пример из языка без хойстинга. Например, Clojure:

```clj
(defn test [] ; Объявление функции `test` (без аргументов)
  (println x) ; Исключение RuntimeException: Unable to resolve symbol: x in this context
)

(def x "foo") ; Объявление переменной x со значением "foo"
(test) ; Вызов функции test
```

Обратите внимание, что исключение выбрасывается уже на этапе объявления функции!
До её вызова дело даже не доходит. Т.е. "нормальный", с т.з. JS код вида:

```
function test() {
  console.log(x)
}

let x = "foo"
test() // ⎙ "foo"
```

в Clojure не работает и исправляется... мануальным "хойстингом":

```clj
; Workaround
(def x "foo") ; !!!

(defn test []
  (println x) ; ок
)

(test) ; Вызов функции test ⎙ "foo"
```

Нетрудно понять, что для файла экспортирующего множество функций вы будете вынуждены
или объявлять их от низкоуровневых к высокоуровневым (*что не всегда желательно*) или прописывать
опережающие декларации для каждой функции, чтобы не зависеть от порядка.
В этом плане, Clojure оказывается ультра-императивным языком, сравнительно с JS.

Таким образом, хойстинг служит для повышения декларативности языка
и снятия неудобных ограничений при объявлении функций. Например,
следующее рекурсивное определение факториала возможно только благодаря хойстингу:

```js
let factorial = function(n) {
  if (n == 0) return 1
  else        return n * factorial(n - 1) // переменная уже известна на этапе парсинга
}
```

При декларации `function` хойстинг "подтягивает" не только переменной, но и
всё тело функции:

```js
test() // ⎙ "hi!"

function test() {
  console.log("hi!")
}
```

Это ещё один "обычный" пример, совершенно непредставимый во
многих других языках.

Теперь сравним различные декларации с точки зрения области видимости,
хойстинга и изменения свойств глобального объекта:

<table>
<tr>
  <th>Declaration</th>
  <td>Hoisting</td>
  <td>Scope</td>
  <td>Modifies Global Object</td>
</tr>
<tr>
  <th><code>var</code></th>
  <td>Initialization</td>
  <td>Function</td>
  <td>Yes</td>
</tr>
<tr>
  <th><code>let</code></th>
  <td>Initialization + TDZ</td>
  <td>Block</td>
  <td>Yes</td>
</tr>
<tr>
  <th><code>const</code></th>
  <td>Initialization + TDZ</td>
  <td>Block</td>
  <td>No</td>
</tr>
<tr>
  <th><code>function</code></th>
  <td>Full</td>
  <td>Block</td>
  <td>Yes</td>
</tr>
<tr>
  <th><code>class</code></th>
  <td>No</td>
  <td>Block</td>
  <td>No</td>
</tr>
<tr>
  <th><code>import</code></th>
  <td>Full</td>
  <td>Module</td>
  <td>No</td>
</tr>
</table>



