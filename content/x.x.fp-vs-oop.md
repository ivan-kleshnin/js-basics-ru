# FP против OOP

Начнём с развенчания наиболее устойчивых мифов о двух крупнейших парадигмах.

## Миф №1: ООП это не ООП

> В реальности, всё не так как на самом деле!<br/>
> – каждый адвокат ООП

Вводя термин объектно-ориентированного программирования, Alan Kay говорил
о распределённых системах. В этом контексте, локальные мутабельные состояния являются неизбежными
и приобретают совсем другой смысл. Однако, мы довольно часто не используем термины в их оригинальных
значениях. Для абстрактных понятий, дрейф их значений – больше правило, чем исключение.
В Computer Science похожая история происходит сейчас с термином FRP, да и многими другими. Хорошо это или плохо, –
но за пределами юриспруденции, смысл терминов определяется массами. А ссылка на первоисточник
как на "неоспоримый аргумент" выдаёт догматика или человека с религиозным сознанием.

*Кстати говоря, сама терминология "Посылки сообщения" в Objective-C и др. является карго-культом изначальной идеи.*

Смирившись с тем, что ООП означает сейчас нечто иное, чем имелось в виду автором термина, мы приходим
к вопросу – Что ООП означает сейчас?

> ООП это не про классы!<br/>
> ООП это не про наследование!<br/>
> ООП это не про объекты!<br/>

Адвокаты ООП всё отрицают. Такова их работа!
Иммутабельное ООП без объектов, без наследования, без методов... выглядит подозрительно неотличимым от ФП.
И не существует в природе.

Для выявления "ядра" ООП следует проанализировать языки, общепризнанно относящиеся к этой категории,
и выделить *нечто*: общее между ними и отличающее их от других языков.

В "канонический" список объектно-ориентированных языков, обычно, включают:

* C++
* Java
* Perl
* PHP
* Objective C
* Python
* Ruby
* Self

Общее внутри группы и специфическое вне группы это:

* локальные мутабельные состояния
* поведения, описанные как методы, вместо функций
* механика наследования или делегации
* наличие функций-инициализаторов, объединённых со структурами данных

## Миф №2: В JS особый ООП

> Особый путь!

В предыдущих разделах, мы уже приходили к выводу, что наиболее принципиальным отличием между системами типов
в JS и Java является доступность О-типов в пространстве значений. Это тянет на отличие, но не на революцию.
В Ruby или Python мы находим близкий аналог системы типов JS и "переворот сознания" можно себе представить разве что
в лице Java или C кодеров, испытывающих симптомы детоксикации.

Попытки противопоставить Наследование и Делегацию также выглядят необоснованными. Так уж случилось,
что основная "тема" программирования – семантика, а не реализация. Если поведение делегации эмулирует
поведение наследования во всех основных случаях (а это так) – делегация является аналогом наследования,
а не его противоположностью. Независимо от разницы в реализации (она тоже не такая большая, сорри ту дисаппойнт ю, Кайл).

Возможность создавать объекты без этапа инициализации? Всё ещё является маргинальной идеей и, с точки зрения автора,
не обретёт должной популярности, т.к. является шагом в сторону ФП, без его достижения. "Отступничество" от обоих лагерей,
закономерным образом, крайне сложно продвинуть.

Большинство текстов по классическому ООП сохраняют свою актуальность для JS при замене "классов" на "прототипы"
и "экземпляров" на "объекты". И неудивительно, – ведь прототипная модель JS создавалась (копировалась с Self) для
воссоздания ООП инструментария на уровне значений. Удалось ли это Брендану Айку? Разумеется.

## Проблема выразительности

Ключом к пониманию дилеммы "ООП против ФП" является [Проблема Выразительности](https://en.wikipedia.org/wiki/Expression_problem).
Оригинально сформулированная для статических языков, она продолжает оставаться
актуальной и для языков динамических.

Проблема Выразительности касается вопроса расширяемости кода и формулируется отдельно для
Функциональной и Объектно-ориентированной парадигм.

С точки зрения Ф-парадигмы, мы манипулируем **данными** с помощью **функций** над типами.<br/>
Неудобный Вопрос: как добавить поддержку нового типа к существующей функции, не меняя её исходный код?

С точки зрения ОО-парадигмы, мы модифицируем **экземпляры классов**, путём вызова их методов.<br/>
Неудобный Вопрос: как добавить новое поведение всем экземплярам, не меняя исходный код класса?

### Проблема выразительности для ООП

```js
// Библиотечный код
class Circle {
  area() {
    // ...
  }
}

// Код приложения
// Вопрос: как добавить метод perimiter во все экземпляры Circle?
```

Эту часть проблемы мы будем называть ОО-частью.

### Проблема Выразительности для ФП

```js
// Библиотечный код
calculateArea(circle) {
  // ...
}

// Код приложения
// Вопрос: как добавить поддержку rectangle в calculateArea?
```

Эту часть проблемы мы будем называть Ф-частью.

## Решения проблемы выразительности

Важно понимать, что решение Проблемы Выразительности подразумевает работу с оригинального классом (типом)
или функцией. Мы можем унаследовать `Circle` или обвернуть `calculateArea` в новую функцию.
Это снимает вопрос для частного приложения, но не для библиотек в общем случае (проблема зависимостей).

Разные языки предоставляют разные (или никакие...) решения Проблемы Выразительности.

В строгой трактовке, Проблема Выразительности читается как "техническая невозможность добавления X".<br/>
В вольной трактовке, Проблема Выразительности читается как "пользовательские либо архитектурные сложности с добавлением X".

### Решения для ОО части

Начнём с ОО-части проблемы. В узкой трактовке, она решается в JS манки-патчем:

```js
// Код приложения
// Вопрос: как добавить метод perimiter во все инстансы Circle?

// Ответ: манки-патч!
Circle.prototype.perimiter = function () {
  // ...
}
```

Мы уже знаем, что манки-патч – паллиатив, применимый только
в частных случаях. Существует ли универсальное решение?

Удивительным образом, JS содержит практически готовый механизм для этого, но (в текущих версиях) не
доводит его логику до конца. Это – динамический this:

```js
perimeter.call(circle)
```

Динамический this (в противовес лексическому) делает возможным текущий API RxJS:

```js
observable
  .map(...)
  .let(doX) // инъекция "метода"
  .let(doY) // ...
  .filter(...)
```

Технически, проблема решена или, по меньшей мере, минимизирована до приемлемого уровня.
Мы можем "добавлять" новое поведение существующим "классам"! К сожалению, данный метод
является специфическим для библиотеки. Некоторые используют термин `.let`, некоторые – `.through`
и так далее.

Законченное решение, с точки зрения автора, будет заключаться в переводе данной конвенции
на уровень общепринятой либо, ещё лучше, на уровень синтаксиса:

```js
observable
  .map(...)
  ::doX() // инъекция "метода"
  ::doY() // ...
  .filter(...)
```

### Решения для Ф-части

Ф-часть Проблемы Выразительности в JS, формально, не решена. Как могло бы выглядеть решение?

Clojure, например, предоставляет мультиметоды и протоколы, позволяющие дополнить функцию на уровне модуля новым поведением.
Это решение, вполне подходящее для динамической типизации.

Haskell отталкивается от теории типов и предлагает строить функции на базе интерфейсов, а не конкретных типов.
Функции над конкретными типами, при этом, остаются участниками Проблемы Выразительности.

Роль интерфейсов в JS выполняет Утиная Типизация. Поэтому, неожиданным, решением
Ф-части проблемы Выразительности оказывается разделение кода на слои, где внешний слой
делается функциональным, а внутренний – объектно-ориентированным. Разница между типами, при этом,
сглаживается диспатчем на метод:

```js
// Код приложения
// Вопрос: как добавить поддержку другой фигуры в calculateArea?

// Ответ: никак. Но, если бы calculateArea принимало figure, то –
calculateArea(figure) {
  return figure.area()
}
```

Библиотека Ramda, подобным образом, решает Проблему Выразительности для коллекций:

```js
function map(fn, coll) {
  if (coll.map) {         // диспатч на метод map
    return coll.map(fn)
  } else if (coll.next) { // диспатч на протокол итерации
    for (x of coll) {
      // ...
    }
  } else {
    // ...
  }
}
```

Такое решение относится к категории архитектурных (т.е. близких, по своей сути, к конвенциям / парадигмам).
Однако оно "работает", а, следовательно, представляет для нас интерес.

На нижнем уровне, мы сохраняем ООП для поддержки мульти-диспатча. Классы (Объекты), при этом,
описывают базовые типы (структуры данных), являются максимально абстрактными и объявляются в редчайших случаях
(стандартные + минимальный набор в библиотеках). Бизнес-логика же строится
на базе функций и типов, объявленных на предыдущем уровне.

Данный подход, с учётом всех возможных факторов, представляется автору оптимальным.


