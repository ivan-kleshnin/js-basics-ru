# Сравнение значений

Сравнение значений в JS часто вызывает сложности у начинающих.
В языке определены два оператора `==` и `===`, разница между которыми
выглядит достаточно просто:

* `==` сравнивает два значения c (опциональной) автокоэрцией
* `===` сравнивает два значения

Никакой другой разницы между операторами нет. Утверждения о том,
что `==` и `===` работают по разному с разными типами или различаются
по строгости являются неверными, т.к. путают причину и следствие.

Иногда можно встретить формулировку "`a === b` – это сокращение для `typeof a == typeof b && a == b`.
Она также концептуально неверна. Никакой проверки на типы `===` не выполняет.

Вы сможете легко объяснить любые результаты работы `==` и `===`, если:

1. знаете как работает автокоэрция в JS
2. знаете как связаны переменные и значения

Для операндов одного типа разница между `==` и `===` отсутствует.
Строго говоря, сравнение разных типов является ошибкой статической типизации
и потому не рекомендуется:

```js
> 1 === 1
true // значения совпадают
> [] === []
false // значения (место в памяти) не совпадают
> 1 == 1
true // значения совпадают
> [] == []
false // значения (место в памяти) не совпадают
```

Для операндов разных типов оператор `==` инициирует автокоэрцию.

```js
> 1 == "1"
true // значения совпадают после коэрции
> 1 === "1"
false // значения не совпадают
```

Как мы помним, для объектов значением переменной является адрес в памяти.
Автокоэрция, в этом случае, также не выполняется. Поэтому, для объектов
`==` и `===` ведут себя одинаково:

```js
> [] == []
false
> [] === []
false
> {} == {}
false
> {} === {}
false
```

Из всего перечисленного видно, что популярная рекомендация "всегда использовать `===`"
не имеет обоснования и является обычным "заклинанием реальности". JS сообщество
выработало и догматически следует нескольким таким мантрам. К сожалению,
никакой практической пользы они не приносят.

Оптимальной реакцией на сравнения двух разных типов является исключения этапа компиляции.
Следующим по оптимальности – исключение этапа выполнения (рантайм).
Наименее оптимальным – автоприведение типов. Независимо от полученного ответа (`true` или `false`),
ваша программа содержит логическую ошибку, если полагается на автокоэрцию. Нет никаких оснований
полагать, что `false` лучше `true` в данном случае. "Не равны" и "нельзя сравнивать" – два взаимоисключающих
утверждения...

Как было указано, для объектов автокоэрция не выполняется и `==` и `===` ведут себя идентично.
Строгие аналоги для операций `>`, `<`, `>=`, `<=` также не определены.

Исходя из вышесказанного, использование `===` вместо `==` являтся неудачной попыткой паллиативного решения.
Строгое сравнение не поможет вам ни найти баг, ни предотвратить его.

Для сравнения объектов рекомендуется использовать библиотечные функции:

```js
> let R = require("ramda")
> R.equals([], [])
true
```


При правильной реализации, подобные функции поддерживают вложенные структуры и диспатчинг
на методы класса, т.е. работают с открытым множеством классов.

Сравнение с возможностью `null` и `undefined` (см. далее) следует выполнять в два этапа:

```js
if (R.isNil(x)) {
 if (equals(x, y)) {
   ...
 } else {
   ...
 }
} else {
  ...
}
```

Тело `R.isNil` эквивалентно `return x === undefined || x === null`

Запутанная реализация сравнения в JS, вероятнее всего, связана с тяжёлым наследием
языка Scheme, где определены [четыре(!)](http://stackoverflow.com/questions/16299246/what-is-the-difference-between-eq-eqv-equal-and-in-scheme)
операции сравнения:

```
=      -- сравнение чисел
eq?    -- сравнение адресов в памяти (implementation specific!)
eqv?   -- сравнение примитивов
equal? -- сравнение объектов (и примитивов)
```

К чести Scheme, `equal?` всё-же входит в базовую поставку.

Для сравнения, в Clojure существует только один оператор сравнения
[`=`](https://clojuredocs.org/clojure.core/=), работающий со всеми типами значений
и один низкоуровневый оператор [`identical?`](https://clojuredocs.org/clojure.core/identical_q)
для сравнения адресов в памяти.
