# Словари

Следует различать идею Записи и идею Словаря. Классически, это разделение выглядит так:

* Запись содержит фиксированное число пар ключ-значение с разными типами значений
* Словарь содержит нефиксированное число пар ключ-значение с одинаковыми типами значений

В идеале, словари сохраняют порядок добавления ключей (пар). Для записей, ключи считаются неупорядоченными.

В качестве словарей в JS традиционно используются:

* Если порядок ключей не имеет значения – объекты `{"1": "john", "2": "jane"}`
* Если порядок ключей имеет значение – массивы пар `[["1", "john"], ["2", "jane"]]`

ES6 вводит новый тип `Map`:

```js
new Map([])
new Map([["1", "a"], ["2", "b"]])
new Map((function* () { yield ["1", "a"] ; yield ["2", "b"]})())
```

Словари поддерживают значения и ключи любых типов. Словари сохраняют порядок добавления ключей.

Для словарей определены базовые свойства:

```js
// Длина словаря
new Map([["1", "a"], ["2", "b"]]).size // 2

// Проверка ключа
new Map([["1", "a"], ["2", "b"]]).has("1") // true
new Map([["1", "a"], ["2", "b"]]).has("3") // false

// Чтение по ключу
new Map([["1", "a"], ["2", "b"]]).get("1") // "a"

// Запись по ключу (мутабельная операция!)
let m = new Map([["1", "a"], ["2", "b"]])
m.set("1", "q") // Map {'1' => 'q', '2' => 'b'}
m               // Map {'1' => 'q', '2' => 'b'}

// Удаление по ключу (мутабельная операция!)
let m = new Map([["1", "a"], ["2", "b"]])
m.delete("1") // true
m             // Map {'2' => 'b'}

// Удаление всех ключей (мутабельная операция!)
let m = new Map([["1", "a"], ["2", "b"]])
m.clear() // undefined
m         // Map {}
```
