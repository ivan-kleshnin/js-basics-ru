# 4.1 Переменные

В JS переменные декларируются перед использованием:

```js
let x
x // undefined
y // ReferenceError
```

Декларация переменной может сопровождаться установкой начального значения:

```js
let x = 1
```

Вы можете декларировать несколько переменных сразу:

```js
let x, y, z = null

// эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать вас давать переменным
короткие имена (плохо именно "подталкивание"). Что ещё более важно, он позволит задать переменным разные
начальные значения, как только это понадобится без реструктурирования кода.

Декларация переменной, технически, разделяется на два этапа: определение идентификатора
и его инициализацию. При этом, данные этапы не всегда выполняются последовательно, даже если
они представляют цельную декларацию в коде. Данное поведение будет описано в следующих разделах.

```js
x = 1 // (попытка) присвоения переменной x значения 1
// если x не объявлен – вызывает ReferenceError (в строгом режиме)
// или устанавливает поле глобального объекта (в нестрогом режиме)
```

```js
let x // декларация без инициализации
// эквивалентна
let x = undefined // инициализации значением undefined
```

В JS определены три ключевых слова для декларации переменных:

```js
var x
let y
const z = undefined // для const исходное значение является обязательным
```

Первичная разница между ними проявляется при попытках передекларации и переинициализации:

```js
// var разрешает передекларацию
var x
var x // ок

// let не разрешает переинициализацию
let y //
let y // SyntaxError: Identifier 'x' has already been declared

// const не разрешает переинициализацию
const z
const z // SyntaxError: Identifier 'x' has already been declared
```

```js
// var разрешает переинициализацию
var x
x = 1 // ок

// let разрешает переинициализацию
let y //
y = 1 // ок

// const не разрешает переинициализацию
const z = undefined
z = 1 // TypeError: Assignment to constant variable.
```

Декларация `const` не делает само значение иммутабельным. В известном смысле, это делает
её "лживой", т.к. деформирует само понятие "константы":

```js
const xs = [] // инициализация мутабельным значением
xs.push(1)    // мутабельная операция
xs            // [1]
```

Разница между тремя декларациями также состоит во влиянии на области видимости (**4.2**),
поведении при хойстинге (**4.3**) и поведении при замыкании (**4.4**).

Как и в других высокоуровневых языках, переменные в JS являются ссылками.

Для П-типов, переменные ссылаются на значение. Для О-типов, переменные ссылаются
на указатель, который ссылается на значение. Поэтому, О-типы иногда называют Референтными типами.

Для иммутабельных примитивов операция присваивания "копирует" значение:

```js
let x = 2 // x ссылается на значение 2
let y = x // y ссылается на значение 2 (копия)
x = 3     // x ссылается на новое значение 3
x         // 3
y         // 2 -- y продолжает ссылаться на 2
```

Для мутабельных объектов присваивание и мутабельные операции (предсказуемо) ведут себя различным образом:

```js
let xs = [2] // xs ссылается на значение [2]
let ys = xs  // ys ссылается на значение [2] (копия указателя на то же значение)
xs = [3]     // xs ссылается на новое значение [3]
xs           // [3]
ys           // [2] -- y продолжает ссылаться на [2]

// но

xs = [2]   // xs ссылается на значение [2]
ys = xs    // ys ссылается на значение [2] (копия указателя на то же значение)
xs.push(3) // мутабельная операция
xs         // [2, 3]
ys         // [2, 3] -- y продолжает ссылаться на [2]
```

Строго говоря, технически, примитивные значения вполне могут не копироваться, а "перессылаться".
Из-за иммутабельности, разница в семантике отсутствует.
Именно так это сделано в Python (образуя, по-сути, рудиментарные Persistent Datastructures).
Однако, в данном гайде мы рассматриваем именно семантику языка, а не его имплементацию,
поэтому не будем углубляться в данный вопрос.

Ссылки на значения играют роль в Сборке Мусора. Значение, на которое не ссылается ни одна переменная,
автоматически удаляется.

С точки зрения типизации, в JS переменные имеют один тип (ссылка). Типы, с которыми мы работаем
на логическом уровне, относятся к самим значениям (для П-типов) или к значениям по ссылке (для О-типов).

TODO добавить диаграмму?!

Для C-программистов: все переменные в JS передаются по значению. Однако, как мы уже знаем, значением
переменной, в случае О-типа, является указатель.

По этой причине, мы не можем переопределить переменную изнутри функции, однако мы можем изменить мутабельные объекты:

```js
function mutatorWannabe(xs) {
  xs = [] // локальная переменная переинициализирована
          // желаемый эффект даст xs.clear() или его аналог (если есть)
}

let gs = [1, 2, 3]
mutatorWannabe(gs)
gs // [1, 2, 3] -- не изменился
```

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs)
gs // [1, 2, 3, 4] -- изменился
```

Поскольку мутабельность является одной из наиболее частых причин багов, многие программисты
вырабатывают стиль, называемый "защитное копирование":

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs.slice()) // создание "защитной" копии
gs // [1, 2, 3] -- не изменился
```

Этот стиль обладает рядом недостатков. Во-первых, не для всех встроенных данных определены
методы копирования. Для копирования записей, например, следует писать собственную функцию или использовать
библиотеку. Копирование хост-объектов (TODO описать или дать ссылку) может быть вообще технически невозможно.
Таким образом, "защитное копирование" является антипаттерном.

Простейшим решением, полностью снимающим необходимость данного антипаттерна,
является отказ от мутабельных операций над аргументами функций.
Общая идея состоит в создании новых объектов на базе старых, без копирования.
Идея реализуется путём использования функциональных хелперов типа `map`, `filter` и т.д.
JS предоставляет минималистичный набор подобных хелперов, однако для полноценной работы вам, вероятно,
понадобится библиотека вроде [RamdaJS](http://ramdajs.com/).

TODO описать глобальный объект
TODO описать хост объекты
