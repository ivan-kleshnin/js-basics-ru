# 4.1 Переменные

В JS переменные декларируются перед использованием:

```js
let x
x // undefined
y // ReferenceError
```

Декларация переменной может сопровождаться установкой начального значения:

```js
let x = 1
```

Вы можете декларировать несколько переменных сразу:

```js
let x, y, z = null

// эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать вас давать переменным
короткие имена (плохо именно "подталкивание"). Что ещё более важно, он позволит задать переменным разные
начальные значения, как только это понадобится без реструктурирования кода.

Декларация переменной, технически, разделяется на два этапа: определение идентификатора
и его инициализацию. При этом, данные этапы не всегда выполняются последовательно, даже если
они представляют цельную декларацию в коде. Данное поведение будет описано в следующих разделах.

```js
x = 1 // (попытка) присвоения переменной x значения 1
// если x не объявлен – вызывает ReferenceError (в строгом режиме)
// или устанавливает поле глобального объекта (в нестрогом режиме)
```

```js
let x // декларация без инициализации
// эквивалентна
let x = undefined // инициализации значением undefined
```

В JS определены три ключевых слова для декларации переменных:

```js
var x
let y
const z = undefined // для const исходное значение является обязательным
```

Первичная разница между ними проявляется при попытках передекларации и переинициализации:

```js
// var разрешает передекларацию
var x
var x // ок

// let не разрешает переинициализацию
let y //
let y // SyntaxError: Identifier 'x' has already been declared

// const не разрешает переинициализацию
const z
const z // SyntaxError: Identifier 'x' has already been declared
```

```js
// var разрешает переинициализацию
var x
x = 1 // ок

// let разрешает переинициализацию
let y //
y = 1 // ок

// const не разрешает переинициализацию
const z = undefined
z = 1 // TypeError: Assignment to constant variable.
```

Декларация `const` не делает само значение иммутабельным. В известном смысле, это делает
её "лживой", т.к. деформирует само понятие "константы":

```js
const xs = [] // инициализация мутабельным значением
xs.push(1)    // мутабельная операция
xs            // [1]
```

Разница между тремя декларациями также состоит во влиянии на области видимости (**4.2**),
поведении при хойстинге (**4.3**) и поведении при замыкании (**4.4**).

Как и в других высокоуровневых языках, переменные в JS являются ссылками.

Для П-типов, переменные ссылаются на значение. Для О-типов, переменные ссылаются
на указатель, который ссылается на значение. Поэтому, О-типы иногда называют Референтными типами.

Поскольку примитивы иммутабельны, разница между копированием примитивного значения
и ссылкой на него существует только на уровне реализации:

```js
let x = 2 // x ссылается на значение 2
let y = x // y ссылается на значение 2
x = 3     // x ссылается на новое значение 3
y         // 2 -- y продолжает ссылаться на 2
```

Ссылки на значения играют роль в Сборке Мусора. Значение, на которое не ссылается ни одна переменная,
автоматически удаляется.

С точки зрения типизации, в JS тип принадлежит не переменной.
Для П-типов типизируется значение, для О-типов – значение по ссылке.

Для C-программистов: все переменные в JS передаются по значению. Однако, как мы уже знаем, значением
переменной может быть указатель (в случае О-типа).

По этой причине, мы не можем переопределить переменную изнутри функции, однако мы можем изменить мутабельные объекты:

```js
function mutatorWannabe(xs) {
  xs = [] // локальная переменная переинициализирована
          // желаемый эффект даст xs.clear() или его аналог (если есть)
}

let gs = [1, 2, 3]
mutatorWannabe(gs)
gs // [1, 2, 3] -- не изменился
```

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs)
gs // [1, 2, 3, 4] -- изменился
```

Поскольку мутабельность является одной из наиболее частых причин багов, многие программисты
вырабатывают стиль, называемый "защитное копирование":

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs.slice()) // создание "защитной" копии
gs // [1, 2, 3] -- не изменился
```

Этот стиль обладает рядом недостатков. Во-первых, не для всех встроенных данных определены
методы копирования. Для копирования записей, например, следует писать собственную функцию или использовать
библиотеку. Копирование хост-объектов (TODO описать или дать ссылку) может быть вообще технически невозможно.
Таким образом, "защитное копирование" является антипаттерном.

Простейшим решением, полностью снимающим необходимость данного антипаттерна,
является отказ от мутабельных операций над аргументами функций.
Общая идея состоит в создании новых объектов на базе старых, без копирования.
Идея реализуется путём использования функциональных хелперов типа `map`, `filter` и т.д.
JS предоставляет минималистичный набор подобных хелперов, однако для полноценной работы вам, вероятно,
понадобится библиотека вроде [RamdaJS](http://ramdajs.com/).

TODO описать глобальный объект
TODO описать хост объекты
