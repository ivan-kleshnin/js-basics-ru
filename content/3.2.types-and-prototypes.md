# Типы и Прототипы

Все значения JS делятся две категории: примитивы и объекты.
Примитивные значения относятся к одному из примитивных типов, а
объекты, соответственно, к одному из объектных типов.

Множество примитивных типов (П) нерасширяемо и состоит из:

* `number`
* `string`
* `boolean`
* `undefined`
* `null`
* `symbol`

Все прочие типы, включая пользовательские, относятся к объектным (О):

* `Number`
* `String`
* `Boolean`
* `Date`
* `RegExp`
* ...

Разница между парами `number` / `Number`, `string` / `String` и др.
будет объяснена далее.

Терминология "примитивных" и "объектных" типов является устоявшейся
(используется в самом JS). Однако автор гайда находит её неудачной
по причине использования слова "тип" в двух различных значения
одновременно.

Читатели, впервые слышащие о данном разделии, обычно, визуализируют его как:

![Некорректная визуализация системы типов в JS](../assets/typesystem-1.png)

На самом деле, оно выглядит примерно так:

![Корректная визуализация системы типов в JS](../assets/typesystem-2.png)

Т.е, упрощённо, объектные типы существуют "внутри" примитивных с несколькими
типами, относящимися к обеим категориями. Теперь рассмотрим различия
между ними более подробно.

#### Примитивные типы

* сущности 2К
* находятся в пространстве типов
* доступны только интерпретатору
* не имеют внутренней структуры
* не связаны друг с другом
* занимают фиксированный размер в памяти (кроме строк)

#### Объектные типы (прототипы)

* сущности 1К
* находятся в пространстве значений
* доступны разработчику
* имеют внутреннюю структуру
* могуть быть связаны друг с другом через т.н. цепочку делегаций
* занимают не фиксированный размер в памяти

Читатели, знакомые с теорией, могут рассмотреть эти категории в ракурсе
номинативных и структурных систем, где первая система соответствует
примитивам (`typeof`) и объектам (`instanceof`), а вторая –
исключительная объектам (утиная типизация).

С позиции примитивных типов, все объектные типы являются
специализациями единственного типа `object`. С позиции объектных типов,
примитивные типы являются сущностями второго класса, не оснащёнными
цепочкой делегации.

Ситуацию усложняется типами, присутствующими на обоих уровнях, а именно:
`function / Function` и `object / Object`. Эти связки уникальны и отличаются
от `number / Number` и т.п.

Всё это выглядит достаточно запутанно. Поэтому, здесь и далее, мы будем
использовать альтернативную терминологию. К счастью, не менее
конвенциональную для JS. Примитивные типы мы будем называть (просто)
**типами**. Объектные типы мы будет называть **прототипами**.

Многим читателям, было бы ещё проще понять эту разницу разделением
на **типы** и **классы**. Это разделение неплохо описывает множество
случаев и механик, однако, технически, некорректно.

Проблема состоит в том, что JS экспозирует низкоуровневые механизмы
для создания объектов. Разделяя единый (в Java, Python, Ruby и т.д.)
этап Инстанциирования на этапы Создания и Инициализации. Объекты в JS
могут создаваться без участия функции-конструктора, т.е. без этапа
Инициализации, абсолютно неизбежного в классическом ООП.

В целом, прототипная модель JS (из которой и происходят данные термины)
является специфической и требует отказа от знакомых категорий.
В том числе, дихотомии класс / экземпляр. Прототипную модель
лучше изучать "с нуля", отказавшись от привычных таксономий.

Для лучшего понимания, сравним JS с другими языками:

* PHP – есть разница между Типами и Классами, Т и К не являются сущностями первого класса
* Java – есть разница между Типами и Классами, Т и К не являются сущностями первого класса
* Ruby – Типы тождественны Классам и являются сущностями первого класса
* Python – Классы описывают свойства Значений, Типы описывают свойства Классов, К и Т являются
сущностями первого класса, Т предназначены для метапрограммирования
* Haskell – есть только Типы (термин Класс используется в другом значении)

В этом плане, JS находится где-то между Java и Ruby.

Разделение между П- и О-типами в JS является вынужденным и обосновано
вопросами производительности. Концепция "everything is an object" была
реализована в SmallTalk и признана непрактичной. Впрочем, в Ruby,
все типы (классы) являются значениями и имеют однородный интерфейс.
Примитивы в этом языке также существуют, но только на уровне реализации.
Идеальный JS, вероятно, выглядел бы сходным образом и экспозировал
только О-типы.

Java-программисты, обычно, не знакомы с понятием классов сущностей и
распространяют миф о "невиданной" системе типов в JS. Однако, это не так.
Система типов в JS, функционально, похожа на таковую в Python или Ruby.
Что, на практике, подтверждается лёгкостью перехода с двух последних
языков на JS.

Ещё раз опишем принятую номенклатуру:

* Примитивные типы – закрытое множество номинативных типов
* Объектные типы / Прототипы – открытое множество структурных типов на уровне значений
* Примитивы – значения типов (примитивных типов)
* Объекты – значения типа `object`, связанные с &gte; Прототипом цепочкой делегаций

Теперь расмотрим практические различия между примитивами и объектами.

#### 1.1. Примитивы описываются литералами

```js
true
null
"foo"
```

**Исключение**: `symbol`

#### 1.2. Объекты описываются конструкторами или литералами

```js
new Date()
new EventEmitter()
new RegExp("john(ny)?")
// vs
[1, 2, 3]
{foo: "FOO"}
/john(ny)?/
```

Обратите внимание на прототип `RegExp`, для которого определён как
литерал, так и функция-конструктор. Литералы объектов могут рассматриваться
как синтаксический сахар. Например, `[1, 2, 3]` соответствует `new Array(1, 2, 3)`.
Впрочем, это правило не универсально.

#### 2.1 Примитивы иммутабельны

```js
let x = "abc"
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // undefined
```

#### 2.2 Объекты мутабельны (по умолчанию)

```js
let x = []
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // 123
```

#### 3.1 Для примитивов определена операция сравнения

```js
1 == 1            // true
1 == 2            // false
true == true      // true
true == false     // false
null == null      // true
null == undefined // false
```

#### 3.2 Для объектов не определена операция сравнения

```js
[] == [] // false
{} == {} // false
```

Причины подобных результатов следуют из технической реализации,
описанной в разделе **Ссылки**. Операция сравнения будет
рассмотрена в отдельной главе.

#### 4.1 Приведение к `boolean` работает для примитивов

```js
Boolean("")  // false
Boolean("0") // true

Boolean(0) // false
Boolean(1) // true
```

#### 4.2 Приведение к `boolean` не работает для объектов

```js
Boolean([]) // true
Boolean({}) // true

// Следовательно
if ([]) {/*...*/} // эквивалентно if (true) {/*...*/}
if ({}) {/*...*/} // эквивалентно if (true) {/*...*/}
```

Привычные для пользователей PHP / Python проверки должны выполняться иначе:

```js
if ([].length) {/*...*/}
if (Object.keys({}).length) {/*...*/}
```

#### 5.1. Примитивы не имеют свойств

При обращении к свойству примитива происходит делегация к свойству обёрточного класса (подробнее – далее).

```js
"foobar".length
// делегируется на
new String("foobar").length
```

#### 5.2 Объекты имеют свойства

Часть свойств описывает поведение объекта и называется методами.
Иногда, свойства противопоставляют методам, что не является технически обоснованным (см. `Object.defineProperty`).
Здесь и далее мы будем рассматривать методы как подмножество свойств, имеющих значение в виде функции.
Примеры свойств:

```js
let r = {              // запись (находится в пространстве значений)
  foo: "foo"           // свойство "foo"
  bar: function () { } // свойство (метод) "bar"
}

class User {           // класс (находится в пространстве значений)
  constructor() {
    this.foo = "foo"   // свойство "foo"
  }

  bar() { }            // свойство (метод) "bar"
}
```

---

Различия между П- и О-типами проявляются во многих аспектах языках: коэрции,
способах проверки типа, операциях сравнения и т.д.

Поскольку объектные типы доступны как значения, мы можем изменить их
поведение одновременно во всей программе. Эта возможность используется
для создания шимов / полифиллов. См. [Monkey-Patch](https://en.wikipedia.org/wiki/Monkey_patch)
Также её можно использовать в приложениях, в особых случаях.
В библиотечном коде, изменение встроенных типов настоятельно не рекомендуется.
См. jQuery vs Prototype, DateJS vs MomentJS...

Для П-типов, данная возможность, предсказуемо, отсутствует.

Механика прототипов и делегаций требует большего объёма знаний и, потому,
будет рассмотрена позднее. До этого момента, мы будем рассматривать
язык с позиции классической типизации и фокусироваться на примитивных типах.







