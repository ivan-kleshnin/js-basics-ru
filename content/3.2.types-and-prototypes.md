# Типы и Прототипы

Все значения JS делятся две категории: примитивы и объекты.

Множество примитивных типов (П) нерасширяемо и состоит из:

* `number`
* `string`
* `boolean`
* `undefined`
* `null`
* `symbol`

Все прочие типы, включая пользовательские, относятся к объектным (О):

* `Number`
* `String`
* `Boolean`
* `Date`
* `RegExp`
* ...

Разница между парами `number` / `Number`, `string` / `String` и др. будет объяснена далее.
Сейчас мы сконцентрируемся на двух системах типизации, которые, фактически, образуют два параллельных подмножества языка.

#### П-типы

* находятся в пространстве типов
* доступны только интерпретатору
* не имеют внутренней структуры
* не связаны друг с другом
* занимают фиксированный размер в памяти (кроме строк)

#### О-типы

* находятся в пространстве значений
* доступны в коде
* имеют внутреннюю структуру
* могуть быть связаны друг с другом через т.н. цепочку прототипов (**5**).
* занимают не фиксированный размер в памяти

Читатели, знакомые с теорией, могут рассмотреть эти категории в ракурсе номинативных
и структурных систем, где первая система соответствует примитивам (`typeof`) и объектам (`instanceof`),
а вторая – только объектам (утиная типизация).

С точки зрения примитивных типов, все объектные типы являются специализациями единственного типа `object`.
Следует чётко понимать, что термин "тип" не эквивалентен между категориями П- и О-типов.

Многим читателям будет проще принять эту разницу, если они, первое время, будут *читать* определение
П-тип как "классический тип" и О-тип как "класс".

П-типы *всегда* описываются литералами и не имеют конструкторов (`Boolean` НЕ является конструктором `true`...).
О-типы, *обычно*, инстанциируются, т.е. создаются с помощью конструктора.

Проблема состоит в том, что JS экспозирует низкоуровневые механизмы для создания объектов.
Разделяя единый (в Java, Python, Ruby и т.д.) этап Инстанциирования на этапы Создания и Инициализации.
Объекты в JS могут создаваться без участия функции-конструктора, т.е. без этапа Инициализации,
абсолютно необходимого в классическом ООП.

Прототипная модель JS (из которой и произрастают данные термины) является специфической для JS
и требует отказа от знакомых категорий (например, дихотомии класс / экземпляр) и изучения "с нуля".
Поэтому, используя предложенный ментальный хак, постарайтесь всё-таки, постепенно,
перестроить своё восприятие на реальную таксономию.

Для лучшего понимания, сравним JS с другими языками:

* PHP – есть разница между Типами и Классами, Т и К не являются сущностями первого класса
* Java – есть разница между Типами и Классами, Т и К не являются сущностями первого класса
* Ruby – Типы тождественны Классам и являются сущностями первого класса
* Python – Классы описывают свойства Значений, Типы описывают свойства Классов, К и Т являются
сущностями первого класса, Т предназначены для метапрограммирования
* Haskell – есть только Типы (термин Класс используется в другом значении)

В этом плане, JS находится где-то между Java и Ruby.

Разделение между П- и О-типами в JS является вынужденным и обосновано вопросами производительности.
Концепция "everything is an object" была реализована в SmallTalk и признана непрактичной.
Впрочем, в Ruby, все типы (классы) являются значениями и имеют однородный интерфейс. Примитивы
в этом языке также существуют, но только на уровне реализации. Идеальный JS, подобным образом, имел бы только О-типы.

Java-программисты, обычно, не знакомы с понятием классов сущностей и распространяют миф о "невиданной" системе типов в JS.
Однако, это не так и система типов в JS, функционально, похожа на таковую в Python или Ruby.
Переход с двух последних языков на JS, обычно, не вызывает особых сложностей.

Во избежание путаницы между типом и значение типа, мы также будем придерживаться отдельной номенклатуры
для последних:

* Примитивы – значения типов (примитивных типов)
* Объекты – значения объектных типов (экземпляры классов)

Теперь расмотрим практические различия между примитивами и объектами.

#### 1.1 Примитивы иммутабельны

```js
let x = "abc"
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // undefined
```

#### 1.2 Объекты мутабельны (по умолчанию)

```js
let x = []
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // 123
```

#### 2.1 Для примитивов определена операция сравнения

```js
1 == 1            // true
1 == 2            // false
true == true      // true
true == false     // false
null == null      // true
null == undefined // false
```

#### 2.2 Для объектов не определена операция сравнения

```js
[] == [] // false
{} == {} // false
```

#### 3.1 Приведение к `boolean` работает для примитивов

```js
Boolean("")  // false
Boolean("0") // true

Boolean(0) // false
Boolean(1) // true
```

#### 3.2 Приведение к `boolean` не работает для объектов

```js
Boolean([]) // true
Boolean({}) // true

// Следовательно
if ([]) {/*...*/} // эквивалентно if (true) {/*...*/}
if ({}) {/*...*/} // эквивалентно if (true) {/*...*/}
```

Привычные для пользователей PHP / Python проверки должны выполняться иначе:

```js
if ([].length) {/*...*/}
if (Object.keys({}).length) {/*...*/}
```

#### 4.1. Примитивы не имеют свойств

При обращении к свойству примитива происходит делегация к свойству обёрточного класса (подробнее – далее).

```js
"foobar".length
// делегируется на
new String("foobar").length
```

#### 4.2 Объекты имеют свойства

Часть свойств описывает поведение объекта и называется методами.
Иногда, свойства противопоставляют методам, что не является технически обоснованным (см. `Object.defineProperty`).
Здесь и далее мы будем рассматривать методы как подмножество свойств, имеющих значение в виде функции.
Примеры свойств:

```js
let r = {              // запись (находится в пространстве значений)
  foo: "foo"           // свойство "foo"
  bar: function () { } // свойство (метод) "bar"
}

class User {           // класс (находится в пространстве значений)
  constructor() {
    this.foo = "foo"   // свойство "foo"
  }

  bar() { }            // свойство (метод) "bar"
}
```

---

Вообще, различия между П- и О-типами проявляются во многих аспектах языках: коэрции,
способах проверки типа, операциях сравнения и т.д.

Поскольку объектные типы доступны как значения, мы можем изменить их поведение одновременно во всей программе.
Эта возможность используется для создания шимов / полифиллов. См. [Monkey-Patch](https://en.wikipedia.org/wiki/Monkey_patch)
Также её можно использовать в приложениях, в особых случаях. В библиотечном коде, изменение встроенных типов настоятельно не рекомендуется.
См. jQuery vs Prototype, DateJS vs MomentJS...

Для П-типов данная возможность, к сожалению, отсутствует.

Мы ещё вернёмся к вопросам различий между П-типами, О-типами и классами в следующих разделах.
