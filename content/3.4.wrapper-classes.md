# 3.4 Обёрточные классы

О-типы в JS, обычно, создаются с помощью функций-конструкторов. В отличие от Python, вызов функции `Foo()`
не эквивалентен инстанциированию `new Foo()` **в общем случае**. Последняя фраза крайне важна.
Иногда эти вызовы могут означать одно и тоже, иногда – нет. Всё зависит от конкретной реализации функции.
Мы вернёмся к этому вопросу позднее, а пока просто возьмём данный факт на заметку.

Для трёх примитивных типов в JS определены обёрточные О-типы:

* `string` &harr; `String`
* `number` &harr; `Number`
* `boolean` &harr; `Boolean`

Литерал `"some"` автоматически конвертируется из примитивного типа `string` в О-тип `String`
при необходимости:

```js
"some".length // 4
// эквивалентно
new String("some").length // 4
```

Данная автокоэрция происходит автоматически при обращении к свойствам примитива.
Использование конструкторов обёрточных типов вручную не рекомендуется, т.к. значения
типов `string` и `String` (`number` и `Number`, `boolean` и `Boolean`) не эквивалентны
и не взаимозаменяемы в общем случае:

```js
typeof "foo"                // "string"
typeof new String("foo")    // "object"
"foo" == new String("foo")  // true
"foo" === new String("foo") // false

typeof false                 // "boolean"
typeof new Boolean(false)    // "object"
false == new Boolean(false)  // true
false === new Boolean(false) // false
```

Поскольку `undefined` и `null` не содержат свойств, типы-обёртки `Null` и `Undefined` в языке не определены.

**Всегда отдавайте предпочтение литералам и не используйте обёрточные типы напрямую**:

```js
[1, 2, 3] /* вместо */ new Array(1, 2, 3)
"foo" /* вместо */ new String("foo")
true /* вместо */ new Boolean(true)
```

Литеральный синтаксис короче и закрыт для потенциальных ошибок:

```js
typeof (new String("foo")) == typeof ("foo") // false -- "object" !== "string"
"foo" === new String("foo")                  // false -- примитив !=== объект
Boolean(new Boolean(false))                  // true  -- приведение типов работает только с примитивами
```

Вызов обёрточных О-типов с объектными аргументами совершенно бесполезен:

```
String({})     // '[object Object]'
new String({}) // [String: '[object Object]'] @_@
```

Новый О-тип `symbol`, добавленный в ES6, бросает исключение при попытке инстанциирования
его функции приведения к типу:

```js
Symbol("unique")     // Symbol(unique)
new Symbol("unique") // TypeError: Symbol is not a constructor
```

Что как-бы намекает на то, что возможность вызвать `Boolean`, `Number` и `String` двумя способами
является ошибкой языка, которую исправили для нового примитивного типа.
