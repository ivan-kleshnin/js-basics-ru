# 3.4 Обёрточные классы

Классы в JS реализуются на базе функций. В отличие от Python, вызов функции `Foo()`
не эквивалентен инстанциированию класса `new Foo()` **в общем случае**. Последняя фраза крайне важна.
Иногда эти вызовы могут означать одно и тоже, иногда – нет. Всё зависит от конкретной реализации.
Мы вернёмся к этому вопросу позднее, а пока просто возьмём данный факт на заметку.

Для трёх примитивных типов в JS определены обёрточные классы:

* `string` &harr; `String`
* `number` &harr; `Number`
* `boolean` &harr; `Boolean`

Литерал `"some"` автоматически конвертируется из примитивного типа `string` в объектный тип `String`
при необходимости:

```js
"some".length // 4
// эквивалентно
new String("some").length // 4
```

Данная автокоэрция происходит автоматически при обращении к свойствам примитива.
Использование конструкторов обёрточных классов вручную не рекомендуется, т.к. значения
типов `string` и `String` (`number` и `Number`, `boolean` и `Boolean`) не эквивалентны
и не взаимозаменяемы в общем случае:

```js
typeof "foo"                // "string"
typeof new String("foo")    // "object"
"foo" == new String("foo")  // true
"foo" === new String("foo") // false

typeof false                 // "boolean"
typeof new Boolean(false)    // "object"
false == new Boolean(false)  // true
false === new Boolean(false) // false
```

Поскольку `undefined` и `null` не содержат свойств, классы-обёртки `Null` и `Undefined` в языке не определены.

**Всегда отдавайте предпочтение литералам и не используйте обёрточные классы напрямую**:

```js
[1, 2, 3] /* вместо */ new Array(1, 2, 3)
"foo" /* вместо */ new String("foo")
true /* вместо */ new Boolean(true)
```

Литеральный синтаксис короче и закрыт для потенциальных ошибок:

```js
typeof (new String("foo")) == typeof ("foo") // false -- "object" !== "string"
"foo" === new String("foo")                  // false -- примитив !=== объект
Boolean(new Boolean(false))                  // true  -- приведение типов работает только с примитивами
```

Вызов обёрточных классов с объектными аргументами совершенно бесполезен:

```
String({})     // '[object Object]'
new String({}) // [String: '[object Object]'] @_@
```
