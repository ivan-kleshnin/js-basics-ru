# Инструкции, Декларации, Выражения

Для изучения JS крайне важно уметь различать основные синтаксические единицы: инструкции,
декларации и выражения. Инструкции и декларации задаются с помощью ключевых слов и операторов.
Как было сказано, грамматика JS весьма обширна и непоследовательна, поэтому вопросы терминологии
заслуживают повторения.

#### Ключевое слово

Комбинация символов, инициирующая Инструкцию или Декларацию.

Примеры: `var`, `let`, `if`, `while`, `for`, `do`

#### Оператор

Комбинация символов, имеющая определённое значение, в контексте кода.
Оператор отличается от ключевого слова тем, что образует Выражение, а не Инструкцию.
Оператор является эквивалентом функции от одного, двух или трёх аргументов.
Операторы могут быть префиксными или инфиксными.

Примеры: `=`, `==`, `&`, `&&`, `+`, `*`, `!`, `typeof`, `delete`, `in`, `_ ? _ : _`

Некоторые операторы (присваивание, тернарный) не могут быть воспроизведены на функциях JS.
Главные причины введения операторов в грамматику: образование перечня имён, защищённых от возможности
перекрытия, получение привычного синтаксиса (арифметические операции), ленивость вычислений.

#### Инструкция

Особая синтаксическая единица, предназначенная для сайд-эффектов (на уровне интепретатора) и не возвращающая значение.
Инструкции образуются с помощью ключевых (зарезервированных) слов.

Примеры:
* `if (false) – условие
* `while (true) – цикл
* `for (let i = 0; i < n; i++) – цикл
* `break` – выход из цикла
* `return` – выход из функции

Большинство инструкций задаётся ключевым словом.
Одним из исключений является присваивание значения, описываемое оператором `=`.

Инструкции могут композироваться по предопределённым правилам.
Инструкции не являются сущностями первого класса (**1.3**).

Большинство инструкций не используется само-по-себе, а сопровождается т.н. Блоком (см. ниже).

#### Декларация

Особая синтаксическая единица, которая обрабатываются до выполнения кода (в статике).
Декларации могут раскладываться на Инструкции или содержит их как свою часть.
Декларации образуются с помощью ключевых (зарезервированных) слов.

Примеры:
* `var x = 2`
* `let y = "foo"`
* `const z = [0, 0, 0]`
* `import "something"`
* `function test () {/*...*/}` (зависит от контекста)

Декларации задаются соотв. ключевыми словами.

Декларации не композируются, однако для них может быть назначен синтаксический сахар:

```js
let x = 1, y = 2
// преобразуется в
let x = 1; let y = 2;
```

Декларации не являются сущностями первого класса (**1.3**).

#### Выражение

Любая синтаксическая единица содержащая (или вычисляющая) значение. Выраж

Примеры: `x`, `2 + 2`, `console.log(x)`, `x > y ? x : y` ...

`console.log` является вырожденным случаем выражения (всегда возвращает `undefined`), которое можно было бы заменить на инструкцию.
См. пример `print x` vs `print(x)` в Python.

В JS выражения всегда синтаксически (статически) композируются, однако эта композиция не всегда имеет логический смысл.
Следующее выражение является синтаксически корректным, но не несёт никакой семантики:

```js
1 + console.log(2) * true
```

Выражения являются сущностями первого класса (**1.3**).

#### Блоки

Блоки в JS задаются фигурными скобками: `{ блок }` и объединяют несколько инструкций.
Блоки предназначены для использования совместно с инструкциями (`for`, `if` и др.):

```js
let word1 = "Hello"; // Эта точка с запятой обязательна

// Блок
{
  let word2 = "blocks!"
  let sentence = word1 + " "+ word2
  console.log(sentence) // Hello blocks!
}

// Инструкция плюс блок:
if (whatever) {
  let word2 = "blocks!"
  let sentence = word1 + " "+ word2
  console.log(sentence) // Hello blocks!
}
```

Блоки могут влиять на область видимости переменных.

---

Некоторые синтаксические конструкции могут выглядеть, на первый взгляд, идентично, но вести
себя по разному, что будет объясняться их категорией:

```js
// foo – декларация
function foo() {}
console.log(foo) // [Function: foo]

// bar – выражение
test(function bar() {})
console.log(bar) // ReferenceError: bar is not defined
```

Далее по тексту мы будем характеризовать ту или иную конструкцию как Декларацию, Выражение, Оператор или Инструкцию.
Избегая, таким образом, дополнительных и дублирующих объяснений.

> Вопрос: валиден ли код `y = let x`?
> Ответ: нет, поскольку `let` образует декларацию, а не выражение.

> Вопрос: можно ли передать конструкцию `if` в качестве аргумента функции?
> Ответ: нет, потому что `if` образует инструкцию, а не выражение.

> Вопрос: можно ли передать выражение с тернарным оператором в качестве аргумента функции?
> Ответ: да, потому что функции принимают выражения в качестве аргументов.

> Вопрос: Почему `min <= x <= max` не работает?! В Питоне работало!!!
> Ответ: композиция данных операторов не имеет семантики. Рассмотрим вариант, где `min`, `x` и `max`
относятся к типу `number`:

> ```js
// Ассоциативность влево:
min <= x <= max
(min <= x) <= max
typeof (min <= x) // "boolean"
typeof max        // "number"
// Сравнение boolean с number не имеет смысла
```

> ```js
// Ассоциативность вправо:
min <= x <= max
min <= (x <= max)
typeof min        // "number"
typeof (x <= max) // "boolean"
// Сравнение number с boolean не имеет смысла
```

> Вывод: в Python, выражение вида `x <= y <= z` работает на хаках (синтаксическом сахаре) парсера.

Строго говоря, разница между Выражением и Инструкцией определяется на уровне интерпретатора, а не синтаксиса
и часто определяется контекстом. Так `x = 2` является выражением, а `x = 2;` – инструкцией (из-за наличия точки с запятой в конце).
Мы не будем углубляться в эти вопросы больше, чем требуется в учебных целях.

Интересующимся, предлагается поэкспериментировать с [демо-парсером](http://esprima.org/demo/parse.html).
