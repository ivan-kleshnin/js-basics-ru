# 4.2 Области видимости

В JS переменные декларируются перед использованием.

```js
let x
x // undefined
y // ReferenceError
```

Вы можете объявлять и инициализировать несколько переменных сразу:

```js
let x, y, z = null

// Эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать вас давать переменным
короткие имена (плохо не "короткое имя", а "подталкивание"). Что ещё более важно, он позволит задать переменным разные
начальные значения, как только это понадобится без реструктурирования кода.

Область видимости переменных в JS натурально ограничивается функциями. Модули ES пока не стандартизированы,
поэтому функции остаются основным инструментом для защиты от столкновений имён. И CommonJS и Webpack модули,
являются эмуляцией и, технически, реализованы на тех же функциях.

В следующем примере, переменные `x` внутри и вне функции `test` являются разными переменными. Внутренняя переменная `x`
перекрывает внешнюю:

```js
function test() {
  let x = "foo"
}

let x = "bar"
```

Переменные не выходят за рамки своего блока видимости:

```js
function test() {
  let x = "foo"
}

console.log(x) // ReferenceError: x is not defined
```

Блок видимости зависит от типа декларации переменной. Для `var` – это функция и только функция.
Для `let` и `const` – это блок, ограниченный фигурными скобочками:

```js
function test() {
  if (true) {
    var x
    let y
  }
  console.log(x) // undefined
  console.log(y) // ReferenceError: y is not defined
}
```

В примере выше, несмотря на вложенность `var x` в условный блок, переменная `x` является
видимой на уровне функции, т.к. именно функция определяет блок видимости для `var`.
Переменная `y` остаётся инкапсулированной внутри условия.

Обычно, механика `let` является предпочтительной. Переменные, объявленные через `let`, не "вылезают"
за рамки циклов и не засоряют область видимости непрошенными именами:

```js
for (let item in items) {
  // ...
}

console.log(item) // ReferenceError
```

TODO: пример с функциями, создаваемыми в цикле

## Замыкания

Поскольку функции являются сущностями первого ранга, мы можем возвращать функцию из функций.
При этом возникает вопрос – должна ли область видимости функции-результата оставаться той,
которой она была на момент создания, или же она должна заменяться на новую в момент вызова.

Если область видимости определяется в момент создания, как в первом случае, она называется
Лексической. Если област видимости определяется в момент вызова, как во втором случае, она называется
Динамической.

В JS используется Лексическая область видимости. Результатом использования этого подхода
является т.н. Замыкание. Замыкание – это запись, в которой хранятся и функция-результат
и ссылки на все переменные из фабричной функции. Эти переменные, остаются
доступны внутри функции-результата (и на чтение и на запись).

В следующем примере, значение, переданное в `makeCounter`, остаётся доступным для функции `inc`, которая
может изменять и возвращать его обычным образом:

```js
function makeCounter(start) {
  return function inc() {
    start++
    return start
  }
}

let inc = makeCounter(5)
inc() // 6
inc() // 7
inc() // 8
```

Замыкание работает на уровне интерпретатора, поэтому в самом коде мы не можем вывести
или посмотреть актуальный контекст. Упрощённо – при возврате функции `inc`, вместо неё возвращается
запись с полями `inc` и `context` и интерпретатор берёт на себя все необходимые при этом преобразования.

TODO пример Динамической области видимости (Clojure)

Замыкания позволяют отказаться от инстанциирования объектов и
резко снижают потребность в объектно-ориентированном программировании.
Они заменяют базовый паттерн Инициализации, т.е. функцию-конструктор.

TODO раскопать причины, почему замыкания не отменили ООП (должны были?!)
