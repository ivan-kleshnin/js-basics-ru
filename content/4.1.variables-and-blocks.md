# 4.2 Области видимости

Область видимости в языке определяется правилами поиска переменных.
Поиск переменной выполняется при чтении (использовании переменной) и при записи (присваивании значения).

В JS переменные декларируются перед использованием:

```js
let x
x // undefined
y // ReferenceError
```

Вы можете объявлять и инициализировать несколько переменных сразу:

```js
let x, y, z = null

// Эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать вас давать переменным
короткие имена (плохо не "короткое имя", а "подталкивание"). Что ещё более важно, он позволит задать переменным разные
начальные значения, как только это понадобится без реструктурирования кода.

Область видимости переменных в JS ограничивается функциями и блоками. Модули ES пока не стандартизированы,
поэтому функции, технически, остаются основным инструментом для защиты от столкновений имён. И CommonJS и Webpack модули,
являются эмуляцией и реализованы на обычных функциях.

Как и в других языках, в JS, при чтении или записи переменной, поиск выполняется от вложенных областей
видимости к внешним. Поиск выполняется до нахождения соответствующего идентификатор или дохождения
до корневой области видимости. В последнем случае, исли идентификатор так и не был найден,
происходит исключение. Если быть точном, разница в поведении различается между строгим и нестрогим
режимами выполнения JS. Однако, в целях уменьшения объёма материала и, руководствуясь предположением
о стандартности строгого режима в близком будущем, – мы будем игнорировать эту разницу и придерживаться
версии strict mode.

В следующем примере, переменные `x` внутри и вне функции `test` являются разными переменными.
Декларация #1 перекрывает декларацию #2:

```js
function test() {
  let x = "foo" // #1
}

let x = "bar" // #2
```

Переменные не выходят за рамки своего блока видимости:

```js
function test() {
  let x = "foo"
}

console.log(x); // ReferenceError: x is not defined
```

Блок видимости зависит от типа декларации переменной. Для `var` – это функция и только функция.
Для `let` и `const` – это блок, ограниченный фигурными скобочками:

```js
function test() {
  if (true) {
    var x
    let y
  }
  console.log(x) // undefined
  console.log(y) // ReferenceError: y is not defined
}
```

В примере выше, несмотря на вложенность `var x` в условный блок, переменная `x` является
видимой на уровне функции, т.к. именно функция определяет блок видимости для `var`.
Переменная `y` остаётся инкапсулированной внутри условия.

Обычно, механика `let` является предпочтительной. Переменные, объявленные через `let`, не "вылезают"
за рамки циклов и не засоряют область видимости непрошенными именами:

```js
for (let item in items) {
  // ...
}

console.log(item) // ReferenceError
```

`let` и `var` по разному ведут себя в `for` циклах:

```
let fns = []
for (let i = 1; i <= 5; i++) {
  fns.push(() => {
    console.log(i)
  })
}
fns.forEach(x => x()) /* 1 2 3 4 5 */

// но

let fns = []
for (var i = 1; i <= 5; i++) {
  fns.push(() => {
    console.log(i)
  })
}
fns.forEach(x => x()) /* 6 6 6 6 6 */
```

Декларация `var` в заголовке цикла создаёт единственную переменную. Каждая лямбда функция
захватывает ссылку на неё. Декларация `let` в заголовке цикла создаёт новую переменную
для каждой итерации.  Каждая лямбда функция захватыет ссылку на соответствующую переменную.
Это объясняет видимый результат.

"Неудачное" поведение `var` в этом случае стало одной из важных причин введения `let` в ES6.

#### Улучшение правил видимости с `let`

Инструкция `let` вводит блочную зону видимости. Блоки обрамляются фигурными скобками: `{ блок }`.
(3) устанавливает локальный (для блока) x в "local" (перекрывая глобальный x).
Инструкция `let` также хойстится внутри блока, однако его блок не обязательно совпадает с функцией!
Кроме того, хойстинг через `let` не разрешает обращаться к переменной до её реальной декларации.

```js
let x = "global" // #1
function f() {
  console.log(x) // #2 "global"
  if (true) {
    // console.log(x) // ReferenceError: x is not defined
    let x = "local"   // #3
  }
  console.log(x) // #4 "global"
}

f()
```

Иногда можно встретить формулировку, что `let` "не хойстится". Однако, это ошибочное мнение.
На практике, хойстинг может читаться как запрет на использование переменной из внешней
области видимости при наличии декларации переменной в текущей области видимости.
В следующем примере, при отсутствии хойстинга, переменная `x` на строке #2 была бы равна "global".
Однако, наличие декларации `let` (ниже по коду!) исключает возможность поиска `x` в других
областях видимости:

```js
let x = "global"   // #1
function f() {
  console.log(x)   // #2 ReferenceError
  let x = "local"  // #3
}

f()
```

TODO хойстинг с поднятием тела функции
TODO привести перечень деклараций, которые хойстятся и не хойстятся
