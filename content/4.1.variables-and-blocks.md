# 4.2 Области видимости

Область видимости определяется правилами поиска переменных.
Поиск переменной выполняется при чтении (использовании переменной) и при записи (присваивании значения).

В JS переменные декларируются перед использованием.

```js
let x
x // undefined
y // ReferenceError
```

Вы можете объявлять и инициализировать несколько переменных сразу:

```js
let x, y, z = null

// Эквивалентно
let x = null
let y = null
let z = null
```

Последний вариант является предпочтительным, т.к. он не будет подталкивать вас давать переменным
короткие имена (плохо не "короткое имя", а "подталкивание"). Что ещё более важно, он позволит задать переменным разные
начальные значения, как только это понадобится без реструктурирования кода.

Область видимости переменных в JS ограничиваются функциями и блоками. Модули ES пока не стандартизированы,
поэтому функции остаются основным инструментом для защиты от столкновений имён. И CommonJS и Webpack модули,
являются эмуляцией и, технически, реализованы на тех же функциях.

В следующем примере, переменные `x` внутри и вне функции `test` являются разными переменными. Внутренняя переменная `x`
перекрывает внешнюю:

```js
function test() {
  let x = "foo"
}

let x = "bar"
```

Переменные не выходят за рамки своего блока видимости:

```js
function test() {
  let x = "foo"
}

console.log(x) // ReferenceError: x is not defined
```

Блок видимости зависит от типа декларации переменной. Для `var` – это функция и только функция.
Для `let` и `const` – это блок, ограниченный фигурными скобочками:

```js
function test() {
  if (true) {
    var x
    let y
  }
  console.log(x) // undefined
  console.log(y) // ReferenceError: y is not defined
}
```

В примере выше, несмотря на вложенность `var x` в условный блок, переменная `x` является
видимой на уровне функции, т.к. именно функция определяет блок видимости для `var`.
Переменная `y` остаётся инкапсулированной внутри условия.

Обычно, механика `let` является предпочтительной. Переменные, объявленные через `let`, не "вылезают"
за рамки циклов и не засоряют область видимости непрошенными именами:

```js
for (let item in items) {
  // ...
}

console.log(item) // ReferenceError
```

TODO: пример с функциями, создаваемыми в цикле

#### Улучшение правил видимости с `let`

Инструкция `let` вводит блочную зону видимости. Блоки обрамляются фигурными скобками: `{ блок }`.
(3) устанавливает локальный (для блока) x в "local" (перекрывая глобальный x).
Инструкция `let` также хойстится внутри блока, однако его блок не обязательно совпадает с функцией!
Кроме того, хойстинг через `let` не разрешает обращаться к переменной до её реальной декларации.
TODO в чём тогда смысл хойстинга? -- типа интерпретатор знает, что переменная x будет, но
не разрешает к ней обращаться.

```js
let x = "global" (1)
function f() {
  console.log(x) // (2) => "global"
  if (true) {
    // console.log(x) // ReferenceError: x is not defined
    let x = "local"   // (3)
  }
  console.log(x) // (4) => "global"
}

f()
```



## Variables Are Function-Scoped

The scope of a variable is always the complete function (as opposed to the current block). For example:
function foo() {
    var x = -512;
    if (x < 0) {  // (1)
        var tmp = -x;
        ...
    }
    console.log(tmp);  // 512
}
We can see that the variable tmp is not restricted to the block starting in line (1); it exists until the end of the function.

Variables Are Hoisted
Each variable declaration is hoisted: the declaration is moved to the beginning of the function, but assignments that it makes stay put. As an example, consider the variable declaration in line (1) in the following function:
function foo() {
    console.log(tmp); // undefined
    if (false) {
        var tmp = 3;  // (1)
    }
}
Internally, the preceding function is executed like this:
function foo() {
    var tmp;  // hoisted declaration
    console.log(tmp);
    if (false) {
        tmp = 3;  // assignment stays put
    }
}
