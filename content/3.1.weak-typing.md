# 3.1 Слабая динамическая типизация

JS – это язык со слабой динамической типизацией. В рантайме – всем выражениям и переменным присваивается определённый тип,
меняющийся по необходимости. В статике – все выражения имеют тип `any`.

Ошибки, связанные с типами, выбрасываются для минимального числа ситуаций. "Канонический" пример –
[`undefined is not a function`](https://www.google.com.ua/search?q=undefined+is+not+a+function).
*Кстати, в новых версиях интерпретатора V8 это сообщение обновлено...*

В большинстве случаев, вместо рантайм ошибки, выполняется автоприведение типов (автокоэрция).

```js
true * 7 // 7
// 1 * 7
```

В примере выше, `boolean` приводится к типу `number` (`true -> 1`, `false -> 0`) и операция выполняется
как обычное умножение.

В интернете есть множество таблиц перечисляющих правила автокоэрции ("js wtf stackoverflow").
Почти все они основаны на произвольной логике, которая, в принципе, могла бы быть иной:

```js
1 + "1" // "11"
1 - "1" // 0
```

Правила автокоэрции для сложения выбраны в пользу строк.
Правила автокоэрции для вычитания – в пользу чисел.

Следующая (выдуманная!) версия выглядит не менее обоснованной:

```js
// Fake JS
1 + "1" // 2
1 - "1" // runtime exception
```

С нашей точки зрения, запоминать эти правила не имеет никакого смысла.
Их умышленное использование свидетельствует о низком уровне программиста.

Задним числом, очевидно, что слабая типизация является неудачной моделью для языка.
В том же Python, `1 + "1"` порождает `TypeError: unsupported operand type(s)...`, что гораздо лучше чем автокоэрция,
хотя и хуже чем ошибка компиляции. К сожалению, это решение уже невозможно пересмотреть.
JS содержит оператор `===`, который многими авторами выдаётся за решение проблемы. Но это мнение далеко от истины.

В целом, механизм исключений в JS используется довольно редко – намного реже, чем в том же Python.
Иногда это оказывается удобнее, иногда – нет.

Реальную продуктивность и точность в программирование на JS привносит навык видеть код с позиции
полноценной типизации. Большинство учебных материалов по языку пишется людьми с бэкграундом
в динамических языках (Perl, PHP) или языках с неудачной системой типизации (Java).

Высокоуровневое программирование отличается от низкоуровневого отказом от определённых возможностей,
которые признаются опасными, непродуктивными и т.п.

* Отказ от GOTO &rarr; Структурное программирование
* Отказ от прямой работы с указателями &rarr; Языки высокого уровня
* Отказ от менеджмента памяти &rarr; Языки высокого уровня
* Отказ от мутабельных состояний &rarr; Функциональное программирование
* Отказ от неуправляемых сайд-эффектов &rarr; Функциональное программирование

Отказ может быть реализован на уровне технического запрета на то или иное
действие или же быть согласован на уровне best practices. Последнее также работает неплохо.
JS комьюнити, постепенно, движется в сторону адаптации паттернов функционального программирования
(см. ImmutableJS, RxJS, React, Redux, Ramda и др.)

В хорошем JS коде, переменные не меняют свой тип, а операции, содержащие операнды разных типов,
прописываются в открытой форме: `1 + parseInt(x)`, `String(x) + "1"`.

Все функции JS являются [вариадическими](https://en.wikipedia.org/wiki/Variadic_function). Однако,
с точки зрения дизайна кода, всегда стоит держать в уме возможность статической типизации.
Вопросы сложности сигнатур, оптимальности структур данных, переизбытка полиморфизма, упрощения (устранения)
иерархий классов остаются основными метриками качества API и в динамических языках.

Мы будем использовать фразу "операция определена" для функций, методов и операций JS так, как это
делается в документациях статически типизированных языков. С той разницей, что "неопределённость"
будет означать не ошибку этапа компиляции, а получение *"неведомой фигни"* в рантайме.

Иными словами, хотя `true * true` синтаксически корректно, его семантика нас не интересует.
Она выбрана в известной мере произвольно и данная операция не должна использоваться.
Подобные операции мы будем считать "не определёнными" и не будем
интересоваться их результатами.

Для крупных проектов на JS, сложность ручного отслеживание типов и количество тестов, необходимое
для покрытия логики, быстро выходят за рамки приемлемого. В таких случаях, оптимальным решением
может оказаться интеграция систем статической типизации типа TypeScript или Flow.
