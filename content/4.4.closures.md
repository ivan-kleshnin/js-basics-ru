# 4.2 Замыкания

Поскольку функции в JS являются первоклассными сущностями, мы можем возвращать функцию из функции.
При этом возникает вопрос – должна ли область видимости функции-результата оставаться той,
которой она была на момент создания, или же она должна заменяться на новую в момент вызова.

Если область видимости определяется в момент создания, как в первом случае, она называется
Лексической. Если област видимости определяется в момент вызова, как во втором случае, она называется
Динамической.

В JS используется Лексическая область видимости. Результатом использования этого подхода
является т.н. Замыкание. Замыкание – это запись, в которой хранятся и функция-результат
и ссылки на все переменные из фабричной функции. Эти переменные, остаются
доступны внутри функции-результата (и на чтение и на запись).

В следующем примере, значение, переданное в `makeCounter`, остаётся доступным для функции `inc`, которая
может изменять и возвращать его обычным образом:

```js
function makeCounter(start) {
  return function inc() {
    start++
    return start
  }
}

let inc = makeCounter(5)
inc() // 6
inc() // 7
inc() // 8
```

Замыкание работает на уровне интерпретатора, поэтому в самом коде мы не можем вывести
или посмотреть актуальный контекст. Упрощённо – при возврате функции `inc`, вместо неё возвращается
запись с полями `inc` и `context` и интерпретатор берёт на себя все необходимые при этом преобразования.

TODO пример Динамической области видимости (Clojure)

Замыкания позволяют отказаться от инстанциирования объектов и
резко снижают потребность в объектно-ориентированном программировании.
Они заменяют базовый паттерн Инициализации, т.е. функцию-конструктор.

TODO раскопать причины, почему замыкания не отменили ООП (должны были?!)
