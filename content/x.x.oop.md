# Прототипная модель в JS

Прототипная модель JS создаёт инструментарий ООП на уровне значений. Прежде чем погружаться
во все её тонкости, неплохо будет вспомнить какие проблемы ООП, вообще, призвано решать.

Сделаем это, как обычно, на примере. Предположим, нам нужно создать API для работы с БД.
Мы кое-что понимаем в архитектуре кода, поэтому описываем отдельно класс `Connection` и отдельно
тулкит для создания запросов:

```js
// === Connection.js ===
module.exports = class Connection {
  construct(url) {
    this.conn = ...
  }

  disconnect() {
    // ...
  }
}
```

Мы не смешиваем построение запросов с подключением к БД, поэтому `Connection` не содержит
методов `where`, `select`, `run` и т.д. Опустим структуру билдера в данном описании и посмотрим
как может выглядеть код приложения:

```js
// === app.js ===
let conn = new Connection(url)
// ...
let dataX = table("users").run(conn)
// ...
let dataY = table("articles").run(conn)
// ...
conn.disconnect()
```

Переменная `conn` каким-то образом делается доступной для всех частей приложения и работа с ней,
будь то формирование пула подключений и т.п. нас, в данный момент, не интересует.

Итак, подобный код возможен и мы можете найти похожие примеры в реальных библиотеках.
Рассмотрим теперь версию той же библиотеки, но без использования ООП.

Мы можем реализовать две функции `connect` и `disconnect`:

```js
//  === Connection.js ===
exports.connect = function (url) {
  // ...
}

exports.disconnect = function (conn) {
  // ...
}
```

Код приложения, при этом, будет выглядеть примерно так:

```js
//  === App.js ===
let conn = connect(url)
let dataX = table("users").run(conn)
// ...
let dataY = table("articles").run(conn)
// ...
disconnect(conn)
```

Регресса, по отношению к ООП-версии не заметно, скорее наоборот.

Рассмотрим похожую задачу с доп. условиями. Теперь нам нужно описать объект камеры для движка 3D игры / 3D редактора.
В отличие, от пред. случая, с камерой можно выполнять множетсво модификаций, изменяющих её состояние (мутабельные),
либо возвращающих её новую версию (иммутабельные).

```js
// === Camera.js ===
class Camera {
  constructor(src, target) {
    // [x, y, z] = src
    // [x, y, z] = target
    // ...
    this.src = src
    this.target = target
    this.rotateAmount = []
    this.zoomAmount = 0
  }

  rotateX(x) {
    this.rotateAmount[0] = x
  }

  rotateY(y) {
    this.rotateAmount[1] = y
  }

  rotateZ(z) {
    this.rotateAmount[2] = z
  }

  zoom(amount) {
    this.zoomAmount = amount
  }
}
```

В коде приложения мы создаём несколько камер, добавляем их к объектам сцены и работаем с ними
в процессе анимации:

```js
// === app.js ===
let primaryCamera = new Camera([100, 100, 100], [0, 0, 0])
let secondaryCamera = new Camera([50, 75, 25], [0, 0, 0])
// ...
scene.add(primaryCamera)
scene.add(secondaryCamera)

primaryCamera.rotateX(...)
// ...
secondaryCamera.zoom(20)
// ...
secondaryCamera.zoom(-20)
```

Код `rotateX`, `rotateY`, `rotateZ` и `zoom` выглядит притянутым за уши, однако мы оставляем
себе возможность разместить там доп. логику: отслеживание лимитов приближения / удаления,
вращение на более чем 360&deg; и т.д, сравнительно с тем, что мы получили бы при прямой
модификации свойств `camera.rotateAmount[0] = ...`. В то же время, в JS мы не имеем
приватных полей и эта опция всегда остаётся доступной – на усмотрение разработчика.

Как мог бы выглядеть предущий код без использования ООП:

```js
// === camera-fns.js ===
exports.make = function (src, target) {
  return {
    src,
    target,
    rotation: [0, 0, 0],
    zoom: 0,
  }
}

let rotateLens = lensPath("rotation")
let zoomLens = lensPath("zoom")
let xLens = lensIndex(0)
let yLens = lensIndex(1)
let zLens = lensIndex(2)

exports.rotateX = function (camera, x) {
  return R.set(compose(rotateLens, xLens), x, camera)
}

exports.rotateY = function (camera, y) {
  return R.set(compose(rotateLens, YLens), y, camera)
}

exports.rotateZ = function (camera, z) {
  return R.set(compose(rotateLens, zLens), z, camera)
}

exports.zoom = function (camera, amount) {
  return R.set(zoomLens, amount, camera)
}
```

Все методы переходят в функции с соотв. изменениями имён. Функции являются иммутабельными, т.е.
возвращают новый объект камеры, вместо модификации старого. Это означает, что новый (изменённый) объект
камеры нужно перезаписать поверх старого:

```js
let cameraFns = require("./camera-fns")

let camera = cameraFns.make(...)

scene.add(cameraFns.zoom(camera, 20))
```

При импорте и обращении к хелперу мы иногда вынуждены сохранять неймспейс для защиты от
конфликта имён. В ООП класс является доп. неймспейсом, выполняющим эту функцию.
Ещё одним вариантом, является капитализация имён модулей (`React`):

```js
let Camera = require("./camera")

let camera = Camera.make(...)

scene.add(Сamera.zoom(camera, 20))
```

В этом случае, `Camera.make`  / `Camera.zoom` являются функций модуля (а не статическими методами класса).
Если API нашей игры строго функционально, такой подход имеет право на жизнь. В случае смешения
объектно-ориентированных и функциональных API в рамках одной библиотеки, он, вероятно, будет вызывать
путаницу и не может быть рекомендован.

Впрочем, не будем застревать на именах, поскольку они варьируют от задачи к задаче и стили ООП
и ФП поочерёдно оказываются удобнее в этом узком аспекте.

Пред. код содержит ошибку – "старая" камера не была удалена.

```js
let Camera = require("./camera")

let camera = Camera.make(...)

scene.remove(camera)
scene.add(Сamera.zoom(camera, 20))
```

Внимательный читатель заметит тут сразу несколько проблем.

1. Первая проблема – объектно-ориентированное API сцены начинает входить в противоречие с функциональным API камер.
Удалять камеру перед добавлением – сомнительное удовольствие.

2. Вторая проблема – рост расходов памяти. В момент создания новой камеры и до удаления старой сборщиком
мусора, в памяти находится два объекта вместо одного.

3. Третья проблема – неймспейсы функциональных хелперов и аргумент камеры, как-бы, "дублируют" друг-друга.

Даже в сложнейшей игре или 3D редакторе, обычно, не бывает много камер.
При переходе от камеры к объектам сцены, как мы понимаем, всё вышесказанное остаётся актуально.
Указанные проблемы мультиплицируются и переходят из разряда "шероховатостей" в разряд "неудобств".

Наши действия?

Для решения первой проблемы, мы можем изменить API сцены на функциональный и/или формализовать
идентификаторы камер:

```js
let Camera = require("./camera")

let primaryCamera = Camera.make(...)

scene.cameras.primary = primaryCamera
// ...
scene.cameras.primary = Сamera.zoom(primaryCamera, 20)
```

Дальнейшее развитие кода, вероятно, вынудит нас к созданию хелперов для самой сцены:

```js
let Camera = require("./camera")

let primaryCamera = Camera.make(...)

scene = Scene.addCamera("primary", primaryCamera, scene)
// ...
scene = Scene.addCamera("primary", Camera.zoom(primaryCamera), scene)
``

Ручные идентификаторы также не масштабируются на остальные объекты (мы не хотим придумывать
названия каплям дождя...). Впрочем, мы можем генерировать идентификаторы автоматически.
Отображаемая сцена – прямой аналог базы данных. Мы не хотим дубликатов в БД также как мы не хотим
дубликатов при отображении, даже если последние "незаметны".

Промежуточный вывод – мы можем решить проблему 1., но проблема 2. оказывается гораздо больше, чем
казалась изначально. Временное дублирование камер в памяти – ок. Временное дублирование сцены в
памяти – совершенно не ок.

Или нет? Что если нам нужно вести историю сцен?! В этом случае, дублирования никак не избежать.
[Персистентные структуры данных](https://en.wikipedia.org/wiki/Persistent_data_structure)
используются в функциональных языках для решения проблемы с иммутабельностью.

В случае маленьких структур данных, проще и быстрее создать копию и удалить старую версию (дать ей удалится
сборщиком мусора). В случае больших структур данных, расходы памяти начинают становиться неприемлемыми.
Принцип работы персистентных структур данных напоминает Git. Иммутабельность позволяет свободно
делиться фрагментами структуры в памяти. Производительность, при этом, может как падать так и расти –
по ситуации. Расходы памяти – падают. Безопасность кода (в плане защиты от багов) – резко вырастает.

Рост размера дискового пространства приводит к появлению [баз данных](http://www.datomic.com/), основанных
на той же идее. "Лог изменений всех записей из коробки" – звучит неплохо, согласитесь.

Размер оперативной памяти не позволяет вести неограниченную историю, однако фиксированное количество
"снимков" может быть достаточным в большинстве случаев. Т.е, при переходе от ООП к ФП и иммутабельным
структурам данных, мы получаем автоматическую историю с шерингом памяти.

Персистентные структуры данных не предоставляются языком, однако
могут быть реализованы на уровне [библиотек](https://facebook.github.io/immutable-js/).

При использовании ООП и мутабельных данных – мы выигрываем в памяти в простейших ситуациях.
Но далее, потребность вести историю изменений, мгновенно приводит нас к необходимости либо фундаментальных
архитектурных перестроек (например, хранения истории на сервере со всеми вытекающими следствиями),
либо к толерантности к реальному дублированию объектов без какого-либо шеринга в памяти.

Даже в аспекте визуализации, наиболее выигрышном для ООП, оно оказывается тактически успешным,
но стратегически тупиковым.

Обсудив вопросы памяти, вернёмся к нашему списку. Мы всё ёещё не касались третьей проблемы.

Что если, наш алгорим серьёзно завяза на приближения и удаления камеры:

```js
cameraPlus20 = Camera.zoom(camera, 20)
cameraPlus30 = Camera.zoom(camera, 30)
cameraMinus20 = Camera.zoom(camera, -20)
```

Многовато повторов :( На помощь приходит ~~функция-конструктор~~ каррирование.
Напомним, что каррирование функционирует как автоматический "частичный вызов" функции:

```js
zoom = Camera.zoom(camera) // требует exports.zoom = curry(function() { ... }) в библиотеке

cameraPlus20 = zoom(20)
cameraPlus30 = zoom(30)
cameraMinus20 = zoom(-20)
```

С помощью замыканий и каррирования мы тривиально эмулируем двух-этапную передачу аргументов,
являющуюся базой для привычной ООП архитектуры.

В местах (алгоритмах), где аргументы функций многократно повторяются, мы создаём
новую версию функции, замкнутую на эти аргументы и работаем уже с ней. Чуть больше кода,
чем в ООП-версии, но и намного больше гибкости. В ООП мы просто не можем передать часть аргументов
в конструктор и ожидать, что всё будет рабботать. В этом состоит **фундаментальная** проблема ООП.
Мы всегда должны собрать полный объект, даже если его методы завязаны только на их часть.
В тестировании это приводит к вакханалии с мок-объектами и другим "чёрным чудесам".

Обсудив перспективы "курения", мы, наконец, можем перейти к описанию "сигарет".

Давайте обсудим, чем:

```js
// ООП
class User {
  constructor(name) {
    this.name = name
  }

  sayHi() {
    console.log("Hi, I'm " + this.name + "!")
  }

  sayShutUp() {
    console.log("Shut up, " + this.name + " is telling you!")
  }
}
```

отличается от:

```js
// ФП
function makeUser(name) {
  return {
    sayHi() {
      console.log("Hi, I'm " + name + "!")
    }

    sayShutUp() {
      console.log("Shut up, " + name + " is telling you!")
    }
  }
}
```

1. В ООП версии `this.name` остаётся доступным для изменений через инстанс.<br/>
   В ФП версии строковый `name` иммутабелен.

2. Методы класса `User` существуют в единственном экземпляре. "Методы" записи, возвращаемой
   `makeUser` пересоздаются каждый раз при вызове.

Пункт 1. не столь важен, поскольку мутация переданных аргументов, обычно, считается плохим стилем
и в ООП гайдах. Пункт 2. соответствует легенде, изложенной выше – росту расходов памяти.

Большинство функций можно отвязать от состояния и перенести его в формальные аргументы.
После этого, "бороться" с повторами (коль-скоро такие возникнут) – каррированием.

Если объект создаётся небольшое число раз (как подключение к БД) – проблема не стоит внимания.
"Лишние" функции потеряются на фоне всего остального.

Если объект создаётся многократно, как в случаях с графическими сценами – аргумент про расход
памяти становится актуальным. Мы можем фундаментально пересмотреть архитектуру и отказаться
от локальных состояний. Почти всегда, это хорошая идея, т.к. даёт возможность вести историю,
тривиально сериализовать и десериализовать все объекты (загружать и выгружать в/из localStorage,
в случае браузера).

[Паническая боязнь](https://en.wikipedia.org/wiki/Shell_shock) глобальных состояний характерна
для Java-программистов, работавших с многопоточностью через [низкоуровневые примитивы](https://en.wikipedia.org/wiki/Lock_(computer_science)).
В однопоточной среде JS глобальные состояния не имеют никаких минусов.

При сочетании разных приложений (см. Веб-Компоненты) глобальное состояние может становиться технически
недостижимым, что это не отменяет его преимуществ.

И да, мы также можем отказаться от замыканий и простых функций в пользу классов / прототипов.
Просто нужно отчётливо представлять все ЗА и ПРОТИВ. К сожалению, аргументы ЗА ООП на этом заканчиваются.
А аргументы ПРОТИВ только начинаются и мы перейдём к ним в других разделах.

В данный момент, осторожно, сформулируем, что ООП решает проблему повтора кода, замкнутого
на некое локальное состояние делегацией или наследованием. "В комплекте" идут толерантность к мутациям,
дублирование многих механик языка (модулей, функций, замыканий...) на новом "уровне", поощрение
стиля кодирования, основанного на локальных состояниях, подмена системы типов, потеря авто-поддержки тривиальных
вещей вроде логирования / сериализации / пересылки по сети и т.д. Список можно продолжать.

В рамках JS, без использования решений для иммутабельности, у данного выбора могут быть основания.
Ещё одним аргументом за ООП является отсутствие мультиметодов на уровня языка, и решение Expression Problem
ФП стиля "через" ООП-слой, которое мы рассматриваем в [другом разделе](./x.x.fp-vs-oop).
















