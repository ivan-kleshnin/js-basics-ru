## Записи

Записи в JS описываются встроенным типом `Object`:

```js
{}
{foo: "FOO"}
{foo: {bar: "BAR"}
```

Записи поддерживают значения любых типов и строчные ключи.
Ключи с типом, отличным от `string`, преобразуются в строковую форму автоматически.

Название `Object` (вместо `Record` или `Dict`) сигнализует нам, что в качестве записей в JS
используется не специализированное решение, а нечто особенное. Конкретнее – т.н. "корневой объект".
Выше было указано, что все значения в JS являются объектами и это одно из отражений данного факта.
Организация системы типов будет рассмотрена в следующем разделе. На данном этапе, достаточно понять,
что разговор о записях в JS эквивалентен разговору об объектах.

Ключи в записях могут задаваться как имя переменной или как строковая константа:

```js
// Допустимо
{foo: "FOO"}

// Не допустимо
{foo-bar: "FOO"} // синтаксическая ошибка

// Допустимо
{"foo": "FOO"}

// Допустимо
{"foo-bar": "FOO-BAR"}
```

В формате JSON, который является подмножеством JS, допустим только вариант с кавычками.

В отличие от большинства других языков, синтаксис доступа к свойствам объекта имеет две формы:

```js
let user = {name: "Jack"}
user.name    // "Jack"
user["name"] // "Jack"
```

Квадратные скобочки не обозначают индексирование массива. Это тоже доступ к свойству объекта.
"Точечный" способ короче и чище, однако "скобочный" способ даёт:

1. Возможность доступа по ключу, имя которого не соответствует правилам именования переменных
2. Возможность доступа по ключу, имя которого содержится в переменной

```js
let user = {"-name-": "Jack"}
// user.-name-  // синтаксическая ошибка
user["-name-"]  // "Jack"

let propName = "-name-"
user.propName  // undefined
user[propName] // "Jack"
```

Для записей определены только "статические" функции, находящиеся в "неймспейсе" типа `Object`:

```js
// Длина записи (число свойств)
Object.keys({foo: "FOO"}).length // 1

// Ключи
Object.keys({foo: "FOO", bar: "BAR"})   // ["foo", "bar"]

// Значения
Object.values({foo: "FOO", bar: "BAR"}) // ["FOO", "BAR"]

// Чтение свойства
({foo: "FOO"}).foo // "FOO"
({foo: "FOO"}).bar // undefined

// Проверка на наличие свойства (вместо Чтения для поддержки falsy значений)
({foo: "FOO"}).hasOwnProperty("foo") // true
({foo: "FOO"}).hasOwnProperty("bar") // false

// Удаление свойства (мутабельная операция!)
let r = {foo: "FOO"}
delete r.foo // true
r            // {}

// Объединение объектов (мутабельная операция!)
Object.assign({a: "A"}, {a: "A"})             // {a: "A"}
Object.assign({}, {a: "A"}, {a: "a"})         // {a: "A"} -- с защитой оригинального объекта от мутации
Object.assign({}, {a: {b: "B"}, {a: {c: "C"}) // {a: {c: "C}} -- объединение работает по shallow принципу

// Трансляция
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return Object.assign(z, {[k]: r[k] * 2})
}, {}) // {foo: 0, bar: 2, qux: 4})

// Фильтрация
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return r[k] ? Object.assign(z, {[k]: r[k]}) : z
}, {}) // {bar: 1, qux: 2}

// Свёртка
let r = {foo: 0, bar: 1, qux: 2}
Object.keys(r).reduce((z, k) => {
  return z + r[k]
}, {}) // 3

TODO продолжить
```

Класс `Object` ещё более лимитирован чем `Array`, по причинам, которые станут понятны далее.
Традиционно, работа с записями в JS, выходящая за рамки "доступа по ключу",
сводится к построению массива на базе ключей или значений и его итерации либо "свёртке" (`reduce`) в новый объект.

Свойства записи следует рассматривать как неупорядоченные, даже если последовательность является (кажется) детерминистической.
