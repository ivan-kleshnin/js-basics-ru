# 4.1 Скоупинг

Область видимости в языке определяется правилами поиска переменных. При чтении переменной
выполняется поиск значения, соответствующего искомому именованному идентификатору. При записи
в переменную – поиск самого идентификатора.

```js
console.log(x) // инициирует поиск x на чтение
```

```js
x = 2 // инициирует поиск x на запись
```

Технически, поиск на чтение называется RHS (right-hand side), а поиск на запись – LHS (left-hand side).
Далее, для краткости, мы будем называть область видимости скоупом.

Скоупы в JS формируются функциями и блоками. Модули ES пока не стандартизированы,
поэтому функции остаются основным инструментом для защиты от столкновений имён.
И CommonJS и Webpack модули, являются эмуляцией и реализованы на обычных функциях.

Скоупы вкладываются один в другой:

```js
// begin scope-0
function() {
  // begin scope-1
  if (whatever) {
    // begin scope-2
    console.log(x)
    // end scope-2
  }
  // end scope-1
}
// end scope-0
```

Как и в других языках, в JS, поиск переменной начинается с текущего скоупа и продолжается
во внешние. Поиск выполняется до обнаружения переменной либо до исчерпания областей.
В последнем случае, исли идентификатор так и не был найден, происходит исключение.

Примечания: разница в реакции на проваленный поиск для LHS различается между строгим и нестрогим режимами выполнения JS.
Однако, в целях уменьшения объёма материала и, руководствуясь гипотезой о вымирании нестрогого режима
в ближайшем будущем, – мы будем игнорировать эту разницу и рассматривать только поведение в strict mode.

В следующем примере, переменные `x` внутри и вне функции `test` являются разными переменными.
Декларация #2 перекрывает декларацию #1 для строки #3:

```js
let x = "outer" // #1

function test() {
  let x = "inner" // #2
  console.log(x)  // #3
}

test() // inner
```

В следующем примере, функция не определяет одноимённой локальной переменной, поэтому использует "глобальную":

```js
let x = "outer"

function test() {
  console.log(x)
}

test() // outer
```


Переменные не выходят за рамки своего блока видимости:

```js
function test() {
  let x = "foo"
}

console.log(x); // ReferenceError: x is not defined
```

Блок видимости зависит от типа декларации переменной. Для `var` – это тело функции.
Для `let` и `const` – это блок, ограниченный фигурными скобочками (в т.ч. тело функции):

```js
function test() {
  if (true) {
    var x
    let y
  }
  console.log(x) // undefined
  console.log(y) // ReferenceError: y is not defined
}
```

В примере выше, несмотря на вложенность `var x` в условный блок, переменная `x` является
видимой на уровне функции, т.к. именно функция определяет блок видимости для `var`.
Переменная `y` остаётся инкапсулированной внутри условия.

Обычно, поведение `let` является предпочтительным. Такие переменные не выходят
за рамки циклов и не засоряют область видимости лишними именами:

```js
let xs = [1, 2, 3]
for (let x of xs) {
  // ...
}
console.log(x) // ReferenceError - ок

let ys = [1, 2, 3]
for (var y of ys) {
  // ...
}
console.log(y) // 3 - засорение скоупа
```

TODO эмуляция модуля
