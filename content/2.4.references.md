# Ссылки

Мы часто говорим *"переменная содержит значение"*. Это технически
неверно, поскольку переменная, на самом деле, ссылается на него.

На уровне реализации, переменная могла бы "содержать" только значение
фиксированной длины, а JS не ограничивает тип переменной. И, следовательно,
не может выделить под неё какое-то фиксированное число байтов.

Однако, мы принимаем эту вольность как желательное упрощение.
Поскольку *все* переменные работают одинаково (как ссылки), мы может
удалить этот уровень абстракции и воспринимать переменные как коробочки
со значениями. Это не повлияет на правильность рассуждений.

Другая ситуация возникает с фразой "тип переменной". Она также неверна
(мы помним, что тип имеет само значение), но она ещё и будет приводить
нас к неверным выводам.

Какие значения может "содержать" переменная? Примитивы и ссылки на объекты.
В последнем случае, технически, переменная ссылается на указатель на объект, т.е.
речь идёт о двойном уровне абстракции. Чтобы упростить пояснение,
далее мы перейдём к концепту "переменной как коробочки со значениями".
К счастью, первый уровень ссылок обрабатывается самим языком и
программист с этим уровнем не взаимодействует.

Итак, когда переменная "содержит" примитив – она содержит его фактическое
значение. Операция присваивания копирует значение:

```js
let x = 2 // x содержит значение 2
let y = x // y содержит копию значения
x = 3     // x содержит значение 3
x         // 3
y         // 2 -- y по прежнему содержит 2
```

Когда переменная содержит ссылку на объект, операция присваивания
копирует эту ссылку, а не само значение:

```js
let xs = [2] // xs содержит указатель на значение [2]
let ys = xs  // ys содержит указатель на значение [2] (вторая ссылка на [2])
xs = [3]     // xs содержит указатель на значение [3]
xs           // [3]
ys           // [2] -- ys по прежнему содержит указатель на [2]

// но

xs = [2]   // xs содержит указатель на значение [2]
ys = xs    // ys содержит указатель на значение [2] (вторая ссылка на [2])
xs.push(3) // мутабельная операция (изменяет значение по указателю)
xs         // [2, 3] -- xs "видит" изменения по указателю
ys         // [2, 3] -- ys также "видит" изменения по указателю
```

Строго говоря, примитивные значения вполне могут не копироваться, а "перессылаться"
при реализации. Из-за иммутабельности, разница в семантике отсутствует.

Именно так это сделано в Python (зачаточные Persistent Datastructures).
Однако, в этом гайде мы рассматриваем именно семантику языка, а не его имплементацию,
поэтому не будем углубляться в данный вопрос.

Ссылки на значения играют роль в Сборке Мусора. Значение, на которое
не ссылается ни одна переменная, автоматически удаляется.

Для C-программистов: все переменные в JS передаются "по значению".
Однако, как мы помним, "значением" переменной, может быть указатель.
По этой причине, мы не можем переопределить саму переменную изнутри функции,
однако мы можем изменить (испортить) мутабельный объект:

```js
function cleanerWannabe(xs) {
  xs = [] // локальная переменная ссылается на новое значение (указатель на массив)
          // желаемый эффект даст xs.clear() или его аналог (если есть)
}

let gs = [1, 2, 3]
clearerWannabe(gs)
gs // [1, 2, 3] -- нет эффекта за пределами функции
```

```js
function cleanerWannabe(xs) {
  xs.push(4) // мутабельная операция, значение по ссылке изменено
}

let gs = [1, 2, 3]
clearerWannabe(gs)
gs // [1, 2, 3, 4] -- эффект за пределами функции
```

Поскольку мутабельность является одной из наиболее частых причин багов,
многие программисты вырабатывают стиль, называемый "защитное копирование":

```js
function mutatorWannabe(xs) {
  xs.push(4) // локальная переменная мутирована
}

let gs = [1, 2, 3]
mutatorWannabe(gs.slice()) // создание "защитной копии"
gs // [1, 2, 3] -- не изменился
```

Этот стиль обладает рядом недостатков. Во-первых, не для всех встроенных
данных определены методы копирования. Для копирования записей, например,
следует писать собственную функцию или использовать библиотеку.
Копирование хост-объектов (TODO описать или дать ссылку) может быть
вообще технически невозможно. Таким образом, "защитное копирование"
является несомненным антипаттерном.

Простейшим решением, полностью снимающим необходимость в последнем,
является отказ от мутабельных операций и переход к созданию новых
объектов  на базе старых, без копирования.

Идея реализуется путём использования функциональных хелперов
типа `map`, `filter` и т.д. JS предоставляет минималистичный набор
подобных хелперов. Для полноценной работы вам, вероятно,
понадобится библиотека вроде [RamdaJS](http://ramdajs.com/).

---

Обратите внимание, что декларация `const` не делает само значение иммутабельным:

```js
const xs = [] // инициализация мутабельным значением
xs.push(1)    // мутабельная операция
xs            // [1]
```

По факту, `const` деформирует классический смысл *константы* и заменяет
универсальное "постоянное значение" на специфическое для JS – "постоянную ссылку".
Автор гайда не использует эту декларацию.
