# 3.5 Записи

В качестве записи в JS принято использовать корневой объект `Object` (см. раздел **Система Типов**), для которого
определён удобный литерал `{}`. Поля записи следует рассматривать как неупорядоченные даже
если в некоторых имплементациях их последовательность является (кажется) детерминистической.

Полезно различать идею Записи и идею Словаря даже если технически они реализуются одинаково.
Запись содержит фиксированное число пар ключ-значение с разными типами значений.
Словарь содержит нефиксированное число пар ключ-значение с одинаковыми типами значений.
В идеале, словари сохраняют порядок добавления ключей (пар). Для записей, ключи считаются неупорядоченными.

`Object` не гарантирует упорядоченность ключей (в порядке объявления или добавления), соответственно, не подходит
для описания словаря в общем случае. Вместо этого следует использовать массив пар или новый тип `Map`,
который был добавлен в ES6 и, пока что, не очень хорошо поддерживается в библиотеках. Последний мы и будем
далее называть Словарём, т.к. прямой перевод (Карта) не очень популярен в русскоязычном пространстве.

Разумеется, использование массива пар и словаря подразумевает разные компромиссы:
O(n) для операции чтения по ключу у массива пар и O(1) у словаря.

```js
// Запись
{
  id: "1",
  name: "admin",
}

// Словарь
[
  ["1", {id: "1", ...}],
  ["2", {id: "2", ...}],
]
```

```js
{} instanceof Object // true
```

```js
let xs = ["foo"] // инициализация массива

let xs = Array(42) // инициализация пустого массива с длиной 42
Array(1)           // [  ] - отображение пустого массива

// Чтение существующего индекса
["foo"][0] // "foo"

// Чтение с перебором индекса
["foo"][1] // undefined

// Чтение с недобором индекса
["foo"][-1] // undefined

// Длина массива
["foo"].length // 1

// Пуш (мутабельный, не рекомендуется)
let xs = ["foo"]
xs.push("bar") // 2
xs // ["foo", "bar"]

// Конкатенация массивов
["foo"].concat(["qux"]) // ["foo", "qux"]

// Срезы массива
["a", "b", "c"].slice(0, 1) // ["a"]
["a", "b", "c"].slice(1, 3) // ["b", "c"]
["a", "b", "c"].slice(-1)   // ["c"]

// Вставка в массив (мутабельная, не рекомендуется)
let xs = ["a", "b", "c"]
xs.splice(1, 0, "b1", "b2")
xs // ["a", "b1", "b2", "b", "c"]

// Трансляция массива
[1, 2, 3].map(x => x * 2) // [2, 4, 6]

// Фильтрация массива
[1, 2, 3].filter(x => x > 2) // [3]

// Свёртка массива
[1, 2, 3].reduce((z, x) => z + x, 0) // 6
```

TODO

Проверка на пустую запись выполняется следующим образом:

```js
// let xs = {}
if (Object.keys(xs).length) { ... }
```

### Приведение типов

```js
// Из массива
[{id: "1"}, {id: "2"}].reduce((memo, item) => {
  memo[item.id] = item ; return z },
{}) // {"1": {id: "1"}, "2": {id: "2"}}

// Из записи в булеан
Boolean(Object.keys([]).length) // false

// Из записи в число
// см. reduce

// Из записи в запись
Object.keys({name: "jack", age: 42}).reduce((memo, key) => { ... }, {})





+++ Проверка полей +++

var myObject = {
  name: '@tips_js'
};

if ("name" in myObject)) { ... } -- включает проверку по цепочке прототипов

if (myObject.name) { ... } -- приводит к Boolean

if (myObject.hasOwnProperty("name")) { ... } -- не приводит к Boolean (поддержка falsy значений)








FIXME
var o = {
  foo() { // возможный шорткат ES2015
  }
  var o = {
    foo: function foo() {
    }
  }
}








