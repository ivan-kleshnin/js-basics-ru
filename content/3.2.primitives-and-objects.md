# 3.2 Примитивы и объекты

Все значения JS делятся две категории: примитивы и объекты. Примитивные значения
относятся к одному из пяти предопределённых примитивных типов. Объекты же относятся к единственному типу,
однако образуют свою собственную систему типов действующую на уровне значений.

Читатели, знакомые с теорией, могут рассмотреть это различие в ракурсе номинативных
и структурных систем, где первая система соответствует примитивам (`typeof`) и объектам (`instanceof`),
а вторая – только объектам (утиная типизация).

Множество примитивных типов (П) нерасширяемо и состоит из:

* `number`
* `string`
* `boolean`
* `undefined`
* `null`

Все прочие типы, включая пользовательские, относятся к объектным (О):

* `Number`
* `String`
* `Boolean`
* `Date`
* `RegExp`
* ...

Разница между парами `number` / `Number`, `string` / `String` и `boolean` / `Boolean`
будет объяснена далее. Сейчас мы сконцентрируемся на двух системах типизации, которые, фактически,
образуют два подмножества языка.

Примитивные типы никак не связаны друг с другом. Объектные типы могут быть
связаны друг с другом через цепочку прототипного наследования. Примитивные типы являются таковыми
в классическом понимании. Они не являются [сущностями первого ранга](https://en.wikipedia.org/wiki/First-class_citizen).
Объектные типы, напротив, являются значениями, т.е. сущностями первого ранга.

Это фундаментальная особенность JavaScript. Мы можем изменить поведение объектов на уровне
всей программы, поскольку объектные типы являются ничем иным, как глобальными мутабельными переменными.
Поведение примитивных типов переопределить нельзя, т.к. они не находятся в пространстве значений.

Для лучшего понимания, сравним JS с другими языками:

* PHP – есть разница между Типами и Классами, Т и К не являются сущностями первого ранга
* Java – есть разница между Типами и Классами, Т и К не являются сущностями первого ранга
* Ruby – Типы тождественны Классам и являются сущностями первого ранга
* Python – Классы описывают свойства Значений, Типы описывают свойства Классов, К и Т являются
сущностями первого ранга, Т предназначены для метапрограммирования
* Haskell – есть только Типы (термин Класс используется в другом значении)

В этом плане JS находится где-то между Java и Ruby.
Возможность менять объектные типы в рантайме следует использовать только в крайних случаях (создание шимов / полифиллов).

Далее по тексту, используя термин "тип" мы будем иметь в виду примитивный тип. Для "объектных типов"
мы будем использовать термин "класс". Данное разделение не было введено в JS изначально, т.к.
долгое время понятие класса отсутствовало в языке. Последние редакции вводят ключевое слово `class`,
которое хорошо соответствует семантике объектного типа. В неочевидных ситуациях, мы будем использовать
полную формулировку.

Часто можно услышать жалобы на данный термин – якобы он не совпадает с "привычным" понятием класса в Java.
Это Java-центристский подход, который автор не разделяет. Технически – это действительно разные вещи.
Класс Java *работает* на уровне компилятора. Класс JS – на уровне кода программы, как обычное значение.
Но назначение у этих двух сущностей совершенно одинаковое – служить фундаментом объектно-ориентированного
программирования.

Разделение между типами и классами в JS является вынужденным и обосновано вопросами производительности.
Концепция "everything is an object" была реализована "влоб" в SmallTalk и признана непрактичной.
Стоит признать, впрочем, что указанную разницу можно было бы оставить сугубо на уровне реализации, как это удалось Ruby.

Примитивы – значения типов (примитивных типов).
Объекты – экземпляры классов (объектных типов).

Рассмотрим различия между примитивами и объектами.

#### 1.1 Примитивы иммутабельны

```js
let x = "abc"
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // undefined
```

#### 1.2 Объекты мутабельны (по умолчанию)

```js
let x = []
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // 123
```

#### 2.1 Для примитивов определена операция сравнения

```js
1 == 1            // true
1 == 2            // false
true == true      // true
true == false     // false
null == null      // true
null == undefined // false
```

#### 2.2 Для объектов не определена операция сравнения

```js
[] == [] // false
{} == {} // false
```

#### 3.1 Приведение к `boolean` работает для примитивов

```js
Boolean("")  // false
Boolean("0") // true

Boolean(0) // false
Boolean(1) // true
```

#### 3.2 Приведение к `boolean` не работает для объектов

```js
Boolean([]) // true
Boolean({}) // true

// Следовательно
if ([]) {/*...*/} // эквивалентно if (true) {/*...*/}
if ({}) {/*...*/} // эквивалентно if (true) {/*...*/}
```

Привычные для пользователей PHP / Python проверки должны выполняться иначе:

```js
if ([].length) {/*...*/}
if (Object.keys({}).length) {/*...*/}
```

#### 4.1. Примитивы не имеют свойств

При обращении к свойству примитива происходит делегация к свойству обёрточного класса (подробнее – далее).

```js
"foobar".length
// делегируется на
new String("foobar").length
```

#### 4.2 Объекты имеют свойства

Часть свойств описывает поведение объекта и называется методами.
Иногда, свойства противопоставляют методам, что не является технически обоснованным (см. `Object.defineProperty`).
Здесь и далее мы будем рассматривать методы как подмножество свойств, имеющих значение в виде функции.
Примеры свойств:

```js
let r = {              // запись (находится в пространстве значений)
  foo: "foo"           // свойство "foo"
  bar: function () { } // свойство (метод) "bar"
}

class User {           // класс (находится в пространстве значений)
  constructor() {
    this.foo = "foo"   // свойство "foo"
  }

  bar() { }            // свойство (метод) "bar"
}
```

Различия между обычными записями, классами, экземплярами классов будут подробно рассмотрены далее.
Сейчас достаточно понять, что все они являются значениями и могут иметь свойства.
