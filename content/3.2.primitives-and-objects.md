# 3.2 Примитивы и объекты

Все значения JS делятся две категории: примитивы и объекты. Примитивные значения
относятся к одному из пяти предопределённых примитивных типов. Объекты же относятся к единственному типу,
однако образуют свою собственную систему типов действующую на уровне значений.

Читатели, знакомые с теорией, могут рассмотреть это различие в ракурсе номинативных
и структурных систем, где первая система соответствует примитивам (`typeof`) и объектам (`instanceof`),
а вторая – только объектам (утиная типизация).

Множество примитивных типов (П) нерасширяемо и состоит из:

* `number`
* `string`
* `boolean`
* `undefined`
* `null`

Все прочие типы, включая пользовательские, относятся к объектным (О):

* `Number`
* `String`
* `Boolean`
* `Date`
* `RegExp`
* ...

Разница между парами `number` / `Number`, `string` / `String` и `boolean` / `Boolean`
будет объяснена далее. Сейчас мы сконцентрируемся на двух системах типизации, которые, фактически,
образуют два подмножества языка.

Примитивные типы никак не связаны друг с другом. Объектные типы могут быть
связаны друг с другом через цепочку прототипного наследования. Примитивные типы являются типами
в классическом понимании. Они не являются [сущностями первого ранга](./1.3.first-class-things).
Объектные типы, напротив, являются значениями, т.е. сущностями первого ранга.

Это фундаментальная особенность JavaScript. Мы можем изменить поведение объектов на уровне
всей программы, поскольку объектные типы находятся в пространстве значений (в мутабельных переменных).
Поведение примитивных типов переопределить нельзя, т.к. они не находятся в пространстве значений.
Возможность менять объектные типы в рантайме пригождается для создания шимов / полифиллов.
См. [Monkey-Patch](https://en.wikipedia.org/wiki/Monkey_patch)
Также её можно использовать в приложениях, в подобных специальных случаях.
В библиотечном коде, изменение встроенных типов настоятельно не рекомендуется.
TODO ссылки на истории: jQuery vs Prototype, DateJS vs MomentJS

Различия между примитивными и объектными типами проявляются во многих аспектах языках: способах
приведения к типу, способах проверки типа и т.д. Далее по тексту, мы будем использовать сокращения "П тип" и "О тип"
там, где разница между этими категориями не может быть проигнорирована.

Многим читателям будет проще принять эту разницу, если они будут *читать* определение
П тип как "классический тип" и О тип как "класс". Разделение тип/класс, в первом приближении, кажется обоснованным.
О типы ("классы"), обычно, инстанциируются, т.е. создаются с помощью конструктора. П типы – всегда описываются литералами
и не имеют конструкторов (`Boolean` НЕ является конструктором `true`...).

Проблема состоит в том, что JS экспозирует низкоуровневые механизмы для создания объектов.
Разделяя единый (в Java, Python, Ruby и т.д.) этап Инстанциирования на этапы Создания и Инициализации.
Поэтому, в JS возможно (и даже рекомендуется многими авторами) создавать объекты не с помощью функции-конструктора,
а с помощью обычной функции-фабрики. По этой причине, автор не вправе навязывать данную таксономию.
Которая, к тому же, не принята в комьюнити по историческим причинам.

Часто можно услышать жалобы на ключевое слово `class` – якобы он не совпадает с "привычным" понятием класса в Java.
Это Java-центристский подход, который автор не разделяет. Технически – это действительно разные вещи.
Класс Java *работает* на уровне компилятора. Класс JS *работает* на уровне кода программы, как обычное значение.
Но назначение у этих двух сущностей совершенно одинаковое – служить фундаментом объектно-ориентированного
программирования.

Поэтому, с небольшими оговорками, вы можете трактовать примитивные типы как *типы в знакомом вам языке*,
и объектные типы – как *классы, доступные в пространстве значений*. Java-программисты, обычно,
не знакомы с понятием рангов сущностей и распространяют миф о якобы "невиданной" системе типов в JS.
Однако, это совершенно не так и система типов в JS *крайне* похожа на таковую в Python или Ruby,
за исключением упомянутой экспозиции низкоуровневых механизмов.

Для лучшего понимания, сравним JS с другими языками:

* PHP – есть разница между Типами и Классами, Т и К не являются сущностями первого ранга
* Java – есть разница между Типами и Классами, Т и К не являются сущностями первого ранга
* Python – Классы описывают свойства Значений, Типы описывают свойства Классов, К и Т являются
сущностями первого ранга, Т предназначены для метапрограммирования
* Ruby – Типы тождественны Классам и являются сущностями первого ранга
* Haskell – есть только Типы (термин Класс используется в другом значении)

В этом плане, JS находится где-то между Java и Ruby.

Разделение между П и О типами в JS является вынужденным и обосновано вопросами производительности.
Концепция "everything is an object" была реализована в SmallTalk и признана непрактичной.
Стоит признать, впрочем, что указанную разницу можно было бы сохранить на уровне скрытой реализации, как это удалось Ruby.

Во избежание путаницы между типом и значение типа, мы также будем придерживаться отдельной номенклатуры
для последних:

* Примитивы – значения типов (примитивных типов)
* Объекты – значения объектных типов (экземпляры классов)

Рассмотрим практические различия между примитивами и объектами.

#### 1.1 Примитивы иммутабельны

```js
let x = "abc"
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // undefined
```

#### 1.2 Объекты мутабельны (по умолчанию)

```js
let x = []
x.foo = 123        // пытаемся добавить свойство "foo"
console.log(x.foo) // 123
```

#### 2.1 Для примитивов определена операция сравнения

```js
1 == 1            // true
1 == 2            // false
true == true      // true
true == false     // false
null == null      // true
null == undefined // false
```

#### 2.2 Для объектов не определена операция сравнения

```js
[] == [] // false
{} == {} // false
```

#### 3.1 Приведение к `boolean` работает для примитивов

```js
Boolean("")  // false
Boolean("0") // true

Boolean(0) // false
Boolean(1) // true
```

#### 3.2 Приведение к `boolean` не работает для объектов

```js
Boolean([]) // true
Boolean({}) // true

// Следовательно
if ([]) {/*...*/} // эквивалентно if (true) {/*...*/}
if ({}) {/*...*/} // эквивалентно if (true) {/*...*/}
```

Привычные для пользователей PHP / Python проверки должны выполняться иначе:

```js
if ([].length) {/*...*/}
if (Object.keys({}).length) {/*...*/}
```

#### 4.1. Примитивы не имеют свойств

При обращении к свойству примитива происходит делегация к свойству обёрточного класса (подробнее – далее).

```js
"foobar".length
// делегируется на
new String("foobar").length
```

#### 4.2 Объекты имеют свойства

Часть свойств описывает поведение объекта и называется методами.
Иногда, свойства противопоставляют методам, что не является технически обоснованным (см. `Object.defineProperty`).
Здесь и далее мы будем рассматривать методы как подмножество свойств, имеющих значение в виде функции.
Примеры свойств:

```js
let r = {              // запись (находится в пространстве значений)
  foo: "foo"           // свойство "foo"
  bar: function () { } // свойство (метод) "bar"
}

class User {           // класс (находится в пространстве значений)
  constructor() {
    this.foo = "foo"   // свойство "foo"
  }

  bar() { }            // свойство (метод) "bar"
}
```

Мы вернёмся к вопросам различий между П типами, О типами и классами в следующих разделах.
