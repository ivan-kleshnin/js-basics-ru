# 3.6 Практические правила

Предыдущие четыре раздела содержали много информации. Поэтому, сейчас
мы повторим практические правила по работе с типами, соблюдение которых избавит нас
от множества проблем.

#### 1\. Никогда не используем обёрточные классы для примитивных типов

См. раздел [**Обёрточные классы**](./2.4.wrapper-classes.md)

#### 2\. Всегда используем конструкторы для объектных типов (классов)

См. раздел [**Приведение типов**](./2.5.type-courcion.md)

#### 3\. Не унифицируем обычный вызов функции и инстанциирование

`new Book({title: "Good Parts"}) /* vs */ Book({name: "Good Parts"})`

Предпочтение левой или правой версии определяется выбранной парадигмой (ООП или ФП).
Функция `Book` всегда должна вызываться или с `new` или без `new` и это должно соответствовать
общему стилю приложения. Часть авторов рекомендует называть фабричные функции в стиле `makeBook`,
чтобы подчеркнуть ненужность `new`. С другой стороны, для библиотек типа Tcomb, которые
как раз-таки эмулируют систему типов, это требование является нереалистичным.

#### 4\. Предпочитаем декларацию `class` для пользовательских объектных типов

Пункт **3**, при этом, соблюдается автоматически.

```js
class User {}
let u = User() // TypeError: Class constructor User cannot be invoked without 'new'
```

--

Разница между способами вызовов функции, равно как и разница между различными паттернами
инициализации объектов, будет рассмотрена далее.

### Примеры

```js
"foo"             // литерал типа `string`                          -- канонично
String("foo")     // функция (приводим к типу `string`)             -- канонично для примитивных аргументов
new String("foo") // инстанциирование (создаём экземпляра `String`) -- не канонично

42                // литерал типа `number`                          -- канонично
String(42)        // функция (приводим к типу `number`)             -- канонично для примитивных аргументов
new Number(42)    // инстанциирование (создаём экземпляра `Number`) -- не канонично

true              // литерал                                         -- канонично
Boolean(1)        // функция (приведения к типу `boolean`)           -- канонично для примитивных аргументов
new Boolean(1)    // инстанциирование (создаём экземпляра `Boolean`) -- не канонично

Date("1999-01-01")     // текущая дата в форме строки, аргумент игнорируется -- не канонично
new Date("1999-01-01") // инстанциирование (создание экземпляра `Date`)      -- канонично

["foo"]                  // литерал                       -- канонично
Array("foo")             // совпадает с инстанциированием -- не канонично
new Array("foo")         // инстанциирование              -- не канонично

{foo: "foo"}}            // литерал                       -- канонично
Object({foo: "foo"})     // совпадает с инстанциированием -- не канонично
new Object({foo: "foo"}) // инстанциирование              -- не канонично

class User {}            // объявление класса       -- канонично
let user = new User()    // инстанциирование класса -- канонично
```
